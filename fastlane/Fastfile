# frozen_string_literal: true

# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version '2.96.0'

default_platform :ios

platform :ios do
  before_all do |lane, options|
    platform = lane.to_s.downcase.include?('tvos') ? 'tvOS' : 'iOS'
    tag_version = options[:tag_version] || tag_version(platform)

    notify_version_to_ci(platform, tag_version, nil) unless lane.to_s.downcase.include?('nightlies')

    if what_s_new_condition(lane)
      what_s_new = what_s_new_for_beta(platform, tag_version)
      if what_s_new.empty?
        UI.user_error! "WhatsNew-#{platform}-beta.json has no release notes for #{tag_version}."
      end
    end

    xcversion(version: '~> 14')

    if cleaned_lane_condition(lane)
      ensure_git_status_clean(show_uncommitted_changes: true, show_diff: true)
      clean_derived_data unless skip_clean_derived_data
    end

    pull_translations unless !pull_translations_lane_condition(lane) || skip_pull_translations
  end

  #
  # Public lanes
  #

  # Nightlies

  desc 'Builds a new iOS nightly on App Center.'
  lane :iOSnightliesAppCenter do
    platform = 'iOS'
    service = 'AppCenter'

    build_number = latest_appcenter_build_number(appcenter_ios_nightly_appcenter_names)
    xcode_override_build_number(platform, build_number + 1)

    tag_version = tag_version(platform)

    branch_name = git_branch_name

    notify_version_to_ci(platform, tag_version, nightly_build_name(branch_name))

    ios_application_schemes.each_index do |index|
      build_lane(
        configuration: 'Nightly_AppCenter',
        scheme: ios_application_schemes[index],
        display_name_suffix: nightly_display_name_suffix(branch_name),
        version_suffix: nightly_version_suffix(branch_name),
        build_name: nightly_build_name(branch_name),
        platform: platform
      )

      appcenter_lane(
        appname: appcenter_ios_nightly_appcenter_names[index],
        destinations: ENV['PLAY_NIGHTLY_APPCENTER_DESTINATIONS'],
        notes: nightly_changelog(platform, service)
      )

      clean_build_artifacts

      UI.success "#{ios_application_schemes[index]} (#{platform} Nightly #{tag_version}) uploaded and distributed. ‚úÖ"
    end

    save_last_nightlies_success_git_commit_hash(platform, service)
  end

  desc 'Builds a new tvOS nightly on App Store Connect and waits for build processing.'
  lane :tvOSnightlies do
    testflight_nightlies(platform: 'tvOS')
  end

  desc 'Builds a new iOS nightly on App Store Connect and waits for build processing.'
  lane :iOSnightlies do
    testflight_nightlies(platform: 'iOS')
  end

  desc 'Adds a nightly TestFlight tester (email required)'
  lane :nightlyTester do |options|
    addTestFlightTester(
      email: options[:email],
      first_name: options[:first_name],
      last_name: options[:last_name],
      app_identifiers: appstore_nightly_identifiers,
      group_name: ENV['ITUNES_CONNECT_TF_GROUPS']
    )
  end

  # Betas

  desc 'Builds an iOS beta on App Center with the current build number. On the develop branch attempts to tag the current version, then bumps the build number and pushes.'
  lane :iOSbetasAppCenter do
    platform = 'iOS'

    tag_version = tag_version(platform)

    ios_application_schemes.each_index do |index|
      build_lane(
        configuration: 'Beta_AppCenter',
        scheme: ios_application_schemes[index],
        display_name_suffix: ' üéØ',
        version_suffix: '-beta',
        platform: platform
      )

      appcenter_lane(
        appname: appcenter_ios_beta_appcenter_names[index],
        destinations: ENV['PLAY_BETA_APPCENTER_DESTINATIONS'],
        notes: what_s_new_for_beta(platform, nil),
        notify_testers: true
      )

      clean_build_artifacts

      UI.success "#{ios_application_schemes[index]} (#{platform} Beta #{tag_version}) uploaded and distributed. ‚úÖ"
    end

    bump_build_number_beta_workflow(platform)
  end

  desc 'Builds a tvOS beta on App Store Connect with the current build number and waits for build processing. On the develop branch attempts to tag the current version, then bumps the build number and pushes.'
  lane :tvOSbetas do
    testflight_betas(platform: 'tvOS')
  end

  desc 'Adds a beta TestFlight tester (email required)'
  lane :betaTester do |options|
    addTestFlightTester(
      email: options[:email],
      first_name: options[:first_name],
      last_name: options[:last_name],
      app_identifiers: appstore_beta_identifiers,
      group_name: ENV['ITUNES_CONNECT_TF_GROUPS']
    )
  end

  # App Store builds

  desc 'Applies iOSUploadAppStoreBuilds and iOSDistributePrivateAppStoreBuilds (or iOSDistributePublicAppStoreBuilds). Optional `public_testflight_distribution` parameter.'
  lane :iOSAppStoreBuilds do |options|
    public_testflight_distribution = options[:public_testflight_distribution] || false
    distribution_scope = public_testflight_distribution ? 'Public' : 'Private'

    UI.important "The AppStore build will be distributed to the #{distribution_scope.downcase} group."

    sh 'bundle exec fastlane ios iOSUploadAppStoreBuilds'
    sh "bundle exec fastlane ios iOSDistribute#{distribution_scope}AppStoreBuilds"
  end

  desc 'Uploads an iOS App Store build on App Store Connect with the current build number.'
  lane :iOSUploadAppStoreBuilds do
    business_units.map do |business_unit|
      sh "bundle exec fastlane ios iOS#{business_unit.downcase}UploadAppStoreBuild"
    end
  end

  desc 'Distributes to private groups an iOS App Store build on App Store Connect with the current version and build numbers. Optional `tag_version` parameter (`X.Y.Z-build_number`).'
  lane :iOSDistributePrivateAppStoreBuilds do |options|
    tag_version = options[:tag_version]

    options = ''
    options += " tag_version:#{tag_version}" if tag_version

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios iOS#{business_unit}DistributePrivateAppStoreBuild#{options}"
    end
  end

  desc 'Distributes to public groups an iOS App Store build on App Store Connect with the current version and build numbers. Optional `tag_version` parameter (`X.Y.Z-build_number`).'
  lane :iOSDistributePublicAppStoreBuilds do |options|
    tag_version = options[:tag_version]

    options = ''
    options += " tag_version:#{tag_version}" if tag_version

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios iOS#{business_unit}DistributePublicAppStoreBuild#{options}"
    end
  end

  desc 'Prepare AppStore iOS releases on App Store Connect with the current version and build numbers. No build uploads. Optional `tag_version` (`X.Y.Z-build_number`) or `submit_for_review` parameters.'
  lane :iOSPrepareAppStoreReleases do |options|
    tag_version = options[:tag_version]
    submit_for_review = options[:submit_for_review]

    options = ''
    options += " tag_version:#{tag_version}" if tag_version
    options += " submit_for_review:#{submit_for_review}" if submit_for_review

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios iOS#{business_unit}PrepareAppStoreRelease#{options}"
    end
  end

  desc 'Applies tvOSUploadAppStoreBuilds and tvOSDistributePrivateAppStoreBuilds (or tvOSDistributePublicAppStoreBuilds). Optional `public_testflight_distribution` parameter.'
  lane :tvOSAppStoreBuilds do |options|
    public_testflight_distribution = options[:public_testflight_distribution] || false
    distribution_scope = public_testflight_distribution ? 'Public' : 'Private'

    UI.important "The AppStore build will be distributed to the #{distribution_scope.downcase} group."

    sh 'bundle exec fastlane ios tvOSUploadAppStoreBuilds'
    sh "bundle exec fastlane ios tvOSDistribute#{distribution_scope}AppStoreBuilds"
  end

  desc 'Uploads a tvOS build on App Store Connect with the current build number.'
  lane :tvOSUploadAppStoreBuilds do
    business_units.map do |business_unit|
      sh "bundle exec fastlane ios tvOS#{business_unit.downcase}UploadAppStoreBuild"
    end
  end

  desc 'Distributes to private groups a tvOS App Store build on App Store Connect with the current version and build numbers. Optional `tag_version` parameter (`X.Y.Z-build_number`).'
  lane :tvOSDistributePrivateAppStoreBuilds do |options|
    tag_version = options[:tag_version]

    options = ''
    options += " tag_version:#{tag_version}" if tag_version

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios tvOS#{business_unit}DistributePrivateAppStoreBuild#{options}"
    end
  end

  desc 'Distributes to public groups a tvOS App Store build on App Store Connect with the current version and build numbers. Optional `tag_version` parameter (`X.Y.Z-build_number`).'
  lane :tvOSDistributePublicAppStoreBuilds do |options|
    tag_version = options[:tag_version]

    options = ''
    options += " tag_version:#{tag_version}" if tag_version

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios tvOS#{business_unit}DistributePublicAppStoreBuild#{options}"
    end
  end

  desc 'Prepare AppStore tvOS releases on App Store Connect with the current version and build numbers. No build uploads. Optional `tag_version` (`X.Y.Z-build_number`) or `submit_for_review` parameters.'
  lane :tvOSPrepareAppStoreReleases do |options|
    tag_version = options[:tag_version]
    submit_for_review = options[:submit_for_review]

    options = ''
    options += " tag_version:#{tag_version}" if tag_version
    options += " submit_for_review:#{submit_for_review}" if submit_for_review

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios tvOS#{business_unit}PrepareAppStoreRelease#{options}"
    end
  end

  # App Store App status

  desc 'Get AppStore App status for iOS and tvOS'
  lane :appStoreAppStatus do
    UI.message '-----'
    business_units.map do |business_unit|
      spaceship_login_with_api_key(business_unit)
      app = spaceship_bu_appstore_build_app(business_unit)
      next unless app

      UI.message '-----'
      ['iOS', 'tvOS'].map do |platform|
        live_version = spaceship_app_live_version(platform, app)
        UI.success "Play #{business_unit} #{platform} live version #{live_version.version_string} (#{live_version.build.version}) is #{live_version.app_store_state}." if live_version
        UI.important "Play #{business_unit} #{platform} has no live version." unless live_version

        latest_version = spaceship_app_latest_known_version(platform, app)
        if !latest_version || latest_version.version_string == live_version.version_string
          UI.message "Play #{business_unit} #{platform} version #{live_version.version_string} (#{live_version.build.version}) is the latest one."
        else
          build_version = latest_version.build ? latest_version.build.version : 'NaN'
          UI.important "Play #{business_unit} #{platform} latest version #{latest_version.version_string} (#{build_version}) is #{latest_version.app_store_state}."
        end
        UI.message '-----'
      end
    end
    UI.message '-----'
  end

  # Public Release notes

  desc 'Publish release notes for iOS and tvOS on Github pages'
  lane :publishReleaseNotes do
    output_directory = "fastlane/export/#{lane_context[SharedValues::LANE_NAME]}"
    Dir.chdir('..') { FileUtils.mkdir_p(output_directory) }
    releases_directory = "#{output_directory}/releases"
    Dir.chdir('..') { FileUtils.mkdir_p(releases_directory) }

    index_html_file = 'fastlane/gh-pages/index.html'
    Dir.chdir('..') { FileUtils.cp(index_html_file, output_directory) }

    business_units.map do |business_unit|
      spaceship_login_with_api_key(business_unit)
      app = spaceship_bu_appstore_build_app(business_unit)

      ['iOS', 'tvOS'].map do |platform|
        UI.message "Preparing Play #{business_unit} #{platform} release notes. üìù"

        live_version = spaceship_app_live_version(platform, app)

        table = release_notes_table_for_html(platform, business_unit)
        divs = release_notes_table_to_html_divs(platform, table, live_version)
        html = release_notes_html(platform, business_unit, divs)

        release_html_file = "release_notes-#{platform.downcase}-#{business_unit.downcase}.html"
        Dir.chdir('..') { File.write("#{releases_directory}/#{release_html_file}", html) }

        upcoming_version = table[0][0]
        upcoming_version = 'NaN' if live_version.version_string == upcoming_version
        UI.success "Computed Play #{business_unit} #{platform} release notes (release: #{live_version.version_string}, upcoming: #{upcoming_version}). ‚úÖ"
      end
    end

    UI.message 'Start Play release notes publication on Github pages.'
    publish_on_github_pages(output_directory, releases_directory)
    UI.success 'Play release notes pushed on Github pages. ‚úÖ'
  end

  # Individual iOS screenshots

  desc 'RSI: Makes iOS screenshots and replaces current ones on App Store Connect.'
  lane :iOSrsiScreenshots do
    platform = 'iOS'

    screenshots(platform, 'RSI')
    upload_screenshots(platform)
  end

  desc 'RTR: Makes iOS screenshots and replaces current ones on App Store Connect.'
  lane :iOSrtrScreenshots do
    platform = 'iOS'

    screenshots(platform, 'RTR')
    upload_screenshots(platform)
  end

  desc 'RTS: Makes iOS screenshots and replaces current ones on App Store Connect.'
  lane :iOSrtsScreenshots do
    platform = 'iOS'

    screenshots(platform, 'RTS')
    upload_screenshots(platform)
  end

  desc 'SRF: Makes iOS screenshots. !!! No replacement made on App Store Connect !!!'
  lane :iOSsrfScreenshots do
    platform = 'iOS'

    screenshots(platform, 'SRF')
    # upload_screenshots(platform) # Don't erase existing ones, from SRF marketing team.
  end

  desc 'SWI: Makes iOS screenshots and replaces current ones on App Store Connect.'
  lane :iOSswiScreenshots do
    platform = 'iOS'

    screenshots(platform, 'SWI')
    upload_screenshots(platform)
  end

  # Individual iOS App Store build uploads

  desc 'RSI only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSrsiUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'RSI')
  end

  desc 'RTR only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSrtrUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'RTR')
  end

  desc 'RTS only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSrtsUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'RTS')
  end

  desc 'SRF only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSsrfUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'SRF')
  end

  desc 'SWI only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSswiUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'SWI')
  end

  # Individual iOS App Store build private distributions

  desc 'RSI only: See `iOSDistributePrivateAppStoreBuilds` lane.'
  lane :iOSrsiDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'iOS', bu: 'RSI', tag_version: options[:tag_version]
    )
  end

  desc 'RTR only: See `iOSDistributePrivateAppStoreBuilds` lane.'
  lane :iOSrtrDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'iOS', bu: 'RTR', tag_version: options[:tag_version]
    )
  end

  desc 'RTS only: See `iOSDistributePrivateAppStoreBuilds` lane.'
  lane :iOSrtsDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'iOS', bu: 'RTS', tag_version: options[:tag_version]
    )
  end

  desc 'SRF only: See `iOSDistributePrivateAppStoreBuilds` lane.'
  lane :iOSsrfDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'iOS', bu: 'SRF', tag_version: options[:tag_version]
    )
  end

  desc 'SWI only: See `iOSDistributePrivateAppStoreBuilds` lane.'
  lane :iOSswiDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'iOS', bu: 'SWI', tag_version: options[:tag_version]
    )
  end

  # Individual iOS App Store build public distributions

  desc 'RSI only: See `iOSDistributePublicAppStoreBuild` lane.'
  lane :iOSrsiDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'iOS', bu: 'RSI', tag_version: options[:tag_version]
    )
  end

  desc 'RTR only: See `iOSDistributePublicAppStoreBuild` lane.'
  lane :iOSrtrDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'iOS', bu: 'RTR', tag_version: options[:tag_version]
    )
  end

  desc 'RTS only: See `iOSDistributePublicAppStoreBuild` lane.'
  lane :iOSrtsDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'iOS', bu: 'RTS', tag_version: options[:tag_version]
    )
  end

  desc 'SRF only: See `iOSDistributePublicAppStoreBuild` lane.'
  lane :iOSsrfDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'iOS', bu: 'SRF', tag_version: options[:tag_version]
    )
  end

  desc 'SWI only: See `iOSDistributePublicAppStoreBuild` lane.'
  lane :iOSswiDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'iOS', bu: 'SWI', tag_version: options[:tag_version]
    )
  end

  # Individual iOS AppStore releases

  desc 'RSI only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSrsiPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'RSI', options)
  end

  desc 'RTR only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSrtrPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'RTR', options)
  end

  desc 'RTS only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSrtsPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'RTS', options)
  end

  desc 'SRF only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSsrfPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'SRF', options)
  end

  desc 'SWI only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSswiPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'SWI', options)
  end

  # Individual tvOS screenshots

  desc 'RSI: Makes tvOS screenshots and replaces current ones on App Store Connect.'
  lane :tvOSrsiScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'RSI')
    upload_screenshots(platform)
  end

  desc 'RTR: Makes tvOS screenshots and replaces current ones on App Store Connect.'
  lane :tvOSrtrScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'RTR')
    upload_screenshots(platform)
  end

  desc 'RTS: Makes tvOS screenshots and replaces current ones on App Store Connect.'
  lane :tvOSrtsScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'RTS')
    upload_screenshots(platform)
  end

  desc 'SRF: Makes tvOS screenshots and replaces current ones on App Store Connect.'
  lane :tvOSsrfScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'SRF')
    upload_screenshots(platform)
  end

  desc 'SWI: Makes tvOS screenshots and replaces current ones on App Store Connect.'
  lane :tvOSswiScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'SWI')
    upload_screenshots(platform)
  end

  # Individual tvOS App Store build uploads

  desc 'RSI only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSrsiUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'RSI')
  end

  desc 'RTR only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSrtrUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'RTR')
  end

  desc 'RTS only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSrtsUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'RTS')
  end

  desc 'SRF only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSsrfUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'SRF')
  end

  desc 'SWI only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSswiUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'SWI')
  end

  # Individual tvOS App Store build private distributions

  desc 'RSI only: See `tvOSDistributePrivateAppStoreBuilds` lane.'
  lane :tvOSrsiDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'tvOS', bu: 'RSI', tag_version: options[:tag_version]
    )
  end

  desc 'RTR only: See `tvOSDistributePrivateAppStoreBuilds` lane.'
  lane :tvOSrtrDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'tvOS', bu: 'RTR', tag_version: options[:tag_version]
    )
  end

  desc 'RTS only: See `tvOSDistributePrivateAppStoreBuilds` lane.'
  lane :tvOSrtsDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'tvOS', bu: 'RTS', tag_version: options[:tag_version]
    )
  end

  desc 'SRF only: See `tvOSDistributePrivateAppStoreBuilds` lane.'
  lane :tvOSsrfDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'tvOS', bu: 'SRF', tag_version: options[:tag_version]
    )
  end

  desc 'SWI only: See `tvOSDistributePrivateAppStoreBuilds` lane.'
  lane :tvOSswiDistributePrivateAppStoreBuild do |options|
    testflight_distribute_private_appstore_build(
      platform: 'tvOS', bu: 'SWI', tag_version: options[:tag_version]
    )
  end

  # Individual tvOS App Store build public distributions

  desc 'RSI only: See `tvOSDistributePublicAppStoreBuilds` lane.'
  lane :tvOSrsiDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'tvOS', bu: 'RSI', tag_version: options[:tag_version]
    )
  end

  desc 'RTR only: See `tvOSDistributePublicAppStoreBuilds` lane.'
  lane :tvOSrtrDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'tvOS', bu: 'RTR', tag_version: options[:tag_version]
    )
  end

  desc 'RTS only: See `tvOSDistributePublicAppStoreBuilds` lane.'
  lane :tvOSrtsDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'tvOS', bu: 'RTS', tag_version: options[:tag_version]
    )
  end

  desc 'SRF only: See `tvOSDistributePublicAppStoreBuilds` lane.'
  lane :tvOSsrfDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'tvOS', bu: 'SRF', tag_version: options[:tag_version]
    )
  end

  desc 'SWI only: See `tvOSDistributePublicAppStoreBuilds` lane.'
  lane :tvOSswiDistributePublicAppStoreBuild do |options|
    testflight_distribute_public_appstore_build(
      platform: 'tvOS', bu: 'SWI', tag_version: options[:tag_version]
    )
  end

  # Individual tvOS AppStore releases

  desc 'RSI only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSrsiPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'RSI', options)
  end

  desc 'RTR only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSrtrPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'RTR', options)
  end

  desc 'RTS only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSrtsPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'RTS', options)
  end

  desc 'SRF only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSsrfPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'SRF', options)
  end

  desc 'SWI only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSswiPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'SWI', options)
  end

  #
  # Private lanes
  #

  desc 'Builds a new nightly on App Store Connect and waits for build processing.'
  private_lane :testflight_nightlies do |options|
    platform = options[:platform] || 'iOS'
    service = 'TestFlight'

    build_number = srg_latest_testflight_build_number(appstore_nightly_identifiers, platform)
    xcode_override_build_number(platform, build_number + 1)

    tag_version = tag_version(platform)

    branch_name = git_branch_name

    notify_version_to_ci(platform, tag_version, nightly_build_name(branch_name))

    schemes = application_schemes(platform)
    schemes.each_index do |index|
      app_identifier = appstore_nightly_identifiers[index]

      build_lane(
        configuration: 'Nightly',
        scheme: schemes[index],
        display_name_suffix: nightly_display_name_suffix(branch_name),
        version_suffix: nightly_version_suffix(branch_name),
        build_name: nightly_build_name(branch_name),
        platform: platform,
        export_to_appstore: true
      )

      pilot_fast_upload(app_identifier, platform)

      UI.success "#{schemes[index]} (#{platform} Nightly #{tag_version}) uploaded. ‚úÖ"

      appcenter_appname = appcenter_testflight_nightly_names(platform)[index]
      upload_appcenter_dsyms(appcenter_appname)

      UI.success "#{schemes[index]} (#{platform} Nightly #{tag_version}) dSYM file OK. ‚úÖ"

      clean_build_artifacts
    end

    changelog = nightly_changelog(platform, service)

    schemes.each_index do |index|
      app_identifier = appstore_nightly_identifiers[index]

      pilot_distribute(app_identifier, platform, tag_version, changelog, false)

      UI.success "#{schemes[index]} (#{platform} Nightly #{tag_version}) distributed. ‚úÖ"
    end

    save_last_nightlies_success_git_commit_hash(platform, service)
  end

  desc 'Builds a beta on App Store Connect with the current build number and waits for build processing. On the develop branch attempts to tag the current version, then bumps the build number and pushes.'
  private_lane :testflight_betas do |options|
    platform = options[:platform] || 'iOS'

    tag_version = tag_version(platform)

    schemes = application_schemes(platform)
    schemes.each_index do |index|
      app_identifier = appstore_beta_identifiers[index]

      can_upload = can_upload_testflight_build(app_identifier, platform, tag_version)
      UI.message "#{schemes[index]} (#{platform} Beta #{tag_version}) already uploaded üîÅ ‚úÖ" unless can_upload
      next unless can_upload

      build_lane(
        configuration: 'Beta',
        scheme: schemes[index],
        display_name_suffix: ' üéØ',
        version_suffix: '-beta',
        platform: platform,
        export_to_appstore: true
      )

      pilot_fast_upload(app_identifier, platform)

      UI.success "#{schemes[index]} (#{platform} Beta #{tag_version}) uploaded. ‚úÖ"

      appcenter_appname = appcenter_testflight_beta_names(platform)[index]
      upload_appcenter_dsyms(appcenter_appname)

      UI.success "#{schemes[index]} (#{platform} Beta #{tag_version}) dSYM file OK. ‚úÖ"

      clean_build_artifacts
    end

    changelog = what_s_new_for_beta(platform, nil)

    schemes.each_index do |index|
      app_identifier = appstore_beta_identifiers[index]

      pilot_distribute(app_identifier, platform, tag_version, changelog, false)

      UI.success "#{schemes[index]} (#{platform} Beta #{tag_version}) distributed. ‚úÖ"
    end

    bump_build_number_beta_workflow(platform)
  end

  desc 'Builds a new App Store build on App Store Connect with the current build number and and skips build processing.'
  private_lane :testflight_appstore_build_upload do |options|
    platform = options[:platform] || 'iOS'
    business_unit = options[:bu]
    scheme = application_scheme(platform, business_unit)

    UI.important 'A valid bu option is required to build an App Store build. Skipping build. ‚ö†Ô∏è' unless scheme
    next unless scheme

    tag_version = tag_version(platform)

    can_upload = can_upload_testflight_build(nil, platform, tag_version)
    UI.message "#{scheme} (#{platform} App Store #{tag_version}) already uploaded üîÅ ‚úÖ" unless can_upload
    next unless can_upload

    build_lane(
      configuration: 'AppStore',
      scheme: scheme,
      platform: platform,
      export_to_appstore: true
    )

    pilot_fast_upload(nil, platform)

    UI.success "#{scheme} (#{platform} App Store #{tag_version}) uploaded ‚úÖ"

    appcenter_appname = appcenter_appstore_build_names(platform)[business_unit_index(business_unit)]
    upload_appcenter_dsyms(appcenter_appname)

    UI.success "#{scheme} (#{platform} App Store #{tag_version}) dSYM file OK. ‚úÖ"

    clean_build_artifacts
  end

  desc 'Distributes the App Store build on App Store Connect with the current build number to private group.'
  private_lane :testflight_distribute_private_appstore_build do |options|
    platform = options[:platform] || 'iOS'
    tag_version = options[:tag_version] || tag_version(platform)
    scheme = application_scheme(platform, options[:bu])

    UI.important 'A valid bu option is required to distribute an App Store build. Skipping distribution. ‚ö†Ô∏è' unless scheme
    next unless scheme

    changelog = what_s_new_for_beta(platform, tag_version)
    pilot_distribute(nil, platform, tag_version, changelog, false)

    UI.success "#{scheme} (#{platform} App Store #{tag_version}) distributed to private beta group. ‚úÖ"
  end

  desc 'Distributes the App Store build on App Store Connect with the current build number to public group.'
  private_lane :testflight_distribute_public_appstore_build do |options|
    platform = options[:platform] || 'iOS'
    tag_version = options[:tag_version] || tag_version(platform)
    scheme = application_scheme(platform, options[:bu])

    UI.important 'A valid bu option is required to distribute an App Store build. Skipping distribution. ‚ö†Ô∏è' unless scheme
    next unless scheme

    changelog = what_s_new_for_beta(platform, tag_version)
    pilot_distribute(nil, platform, tag_version, changelog, true)

    UI.success "#{scheme} (#{platform} App Store #{tag_version}) distributed to public beta group. ‚úÖ"
  end

  desc 'Builds for a scheme and a configuration'
  private_lane :build_lane do |options|
    options[:export_to_appstore] ||= false
    options[:display_name_suffix] ||= ''
    options[:version_suffix] ||= ''
    options[:build_name] ||= ''
    options[:platform] ||= 'iOS'
    options[:version] = xcode_marketing_version(options[:platform])

    options = update_options_to_appstore(options)

    options[:team_id] = app_config.try_fetch_value(:team_id)

    # CI can take time to be ready to start the build
    ENV['FASTLANE_XCODEBUILD_SETTINGS_RETRIES'] = '10'

    destination = "generic/platform=#{options[:platform]}"
    lane_name = lane_context[SharedValues::LANE_NAME]
    output_directory = "fastlane/export/#{lane_name}/"
    gym(
      configuration: options[:configuration],
      scheme: options[:scheme],
      silent: true,
      clean: true,
      xcargs: srg_xcargs(options),
      export_method: options[:export_to_appstore] ? 'app-store' : 'enterprise',
      include_bitcode: false,
      export_team_id: options[:team_id],
      destination: destination,
      derived_data_path: derived_data_path,
      output_directory: output_directory
    )
  end

  desc 'Uploads a build on App Center or just a dSYM file'
  private_lane :appcenter_lane do |options|
    options[:notify_testers] ||= false

    if options[:upload_dsym]
      appcenter_upload(
        api_token: ENV['PLAY_APPCENTER_TOKEN'],
        owner_type: 'organization',
        owner_name: ENV['PLAY_APPCENTER_OWNER'],
        app_name: options[:appname],
        release_notes: options[:notes],
        upload_dsym_only: true,
        dsym: options[:upload_dsym]
      )
    else
      appcenter_upload(
        api_token: ENV['PLAY_APPCENTER_TOKEN'],
        owner_type: 'organization',
        owner_name: ENV['PLAY_APPCENTER_OWNER'],
        app_name: options[:appname],
        release_notes: options[:notes],
        destination_type: 'group',
        destinations: options[:destinations],
        notify_testers: options[:notify_testers]
      )
    end
  end

  desc 'Add tester to TestFlight, by default for betas'
  private_lane :addTestFlightTester do |options|
    email = spaceship_email_required(options[:email])
    email ||= spaceship_email_required(prompt(text: 'email: '))
    return UI.user_error! 'A valid email is required. (email parameter)' unless email

    UI.message "Preparing invitations to #{email}. üì©"

    app_identifiers = options[:app_identifiers] || appstore_beta_identifiers
    group_name = options[:group_name] || ENV['ITUNES_CONNECT_TF_GROUPS']

    spaceship_login

    app_identifiers.each do |app_identifier|
      app = spaceship_app(app_identifier)
      next unless app

      group = spaceship_get_group(app, group_name)
      next unless group

      tester = spaceship_get_tester(app, email)
      if tester
        if tester.status == 'invited'
          spaceship_delete_tester(app, tester)
          UI.message "#{email} was invited as a tester for #{app.name}. Invitation removed. üì® üöÆ"
        else # accepted or installed
          UI.message "#{email} is already a tester for #{app.name} (status: #{tester.status}). üîÅ ‚úÖ"
          next
        end
      end

      spaceship_add_tester(group, email, options[:first_name], options[:last_name])

      UI.success "#{email} tester added to #{group.name} for #{app.name}. Invitation sent. üì® ‚úÖ"
    end
  end

  after_all do |lane|
    if cleaned_lane_condition(lane)
      ENV.delete('DERIVED_DATA_CLEANED')
      reset_git_repo(skip_clean: true)
    end
  end

  error do |lane|
    if cleaned_lane_condition(lane)
      clean_build_artifacts
      ENV.delete('DERIVED_DATA_CLEANED')
      reset_git_repo(skip_clean: true, force: true)
    end
  end
end

#
# Functions
#

def business_units
  ['RTS', 'SRF', 'RSI', 'RTR', 'SWI']
end

def business_unit_index(business_unit)
  business_units.index(business_unit.upcase)
end

def ios_application_schemes
  business_units.map { |business_unit| "Play #{business_unit}" }
end

def tvos_application_schemes
  business_units.map { |business_unit| "Play #{business_unit} TV" }
end

def application_schemes(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    ios_application_schemes
  else
    tvos_application_schemes
  end
end

def application_scheme(platform, business_unit)
  platform ||= 'iOS'

  application_schemes(platform)[business_unit_index(business_unit)]
end

def screenshots_scheme(platform, business_unit)
  platform ||= 'iOS'

  application_scheme = application_scheme(platform, business_unit)
  return unless application_scheme

  "#{application_scheme} screenshots"
end

def app_config
  CredentialsManager::AppfileConfig
end

def what_s_new_condition(lane)
  included_lanes = ['appstorebuild', 'beta']
  (!lane.to_s.downcase.include? 'tester') &&
    included_lanes.one? { |i| lane.to_s.downcase.include? i }
end

def cleaned_lane_condition(lane)
  excluded_lanes = ['distribute', 'screenshots', 'appstorerelease', 'status', 'tester']
  (lane.to_s != 'devLane') &&
    excluded_lanes.all? { |i| !lane.to_s.downcase.include? i }
end

def skip_clean_derived_data
  ENV['DERIVED_DATA_CLEANED'] == '1'
end

def clean_derived_data
  Dir.chdir('..') { FileUtils.remove_entry(derived_data_path, true) }
  ENV['DERIVED_DATA_CLEANED'] = '1'
end

def derived_data_path
  'build/DerivedData'
end

def appcenter_ios_nightly_appcenter_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_NIGHTLY_APPCENTER_APPNAME"] }
end

def appcenter_tv_nightly_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_TV_NIGHTLY_APPCENTER_APPNAME"] }
end

def appcenter_ios_nightly_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_IOS_NIGHTLY_APPCENTER_APPNAME"] }
end

def appcenter_testflight_nightly_names(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    appcenter_ios_nightly_names
  else
    appcenter_tv_nightly_names
  end
end

def appcenter_ios_beta_appcenter_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_BETA_APPCENTER_APPNAME"] }
end

def appcenter_tv_beta_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_TV_BETA_APPCENTER_APPNAME"] }
end

def appcenter_ios_beta_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_IOS_BETA_APPCENTER_APPNAME"] }
end

def appcenter_testflight_beta_names(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    appcenter_ios_beta_names
  else
    appcenter_tv_beta_names
  end
end

def appcenter_tv_appstore_build_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_TV_APPSTORE_APPCENTER_APPNAME"] }
end

def appcenter_ios_appstore_build_names
  business_units.map { |business_unit| ENV["PLAY_#{business_unit}_APPSTORE_APPCENTER_APPNAME"] }
end

def appcenter_appstore_build_names(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    appcenter_ios_appstore_build_names
  else
    appcenter_tv_appstore_build_names
  end
end

def appstore_nightly_identifiers
  business_units.map do |business_unit|
    ENV["ITUNES_CONNECT_NIGHLTY_#{business_unit}_APP_IDENTIFIER"]
  end
end

def appstore_beta_identifiers
  business_units.map do |business_unit|
    ENV["ITUNES_CONNECT_BETA_#{business_unit}_APP_IDENTIFIER"]
  end
end

def appstore_build_identifiers
  business_units.map { |business_unit| ENV["#{business_unit}_APP_IDENTIFIER"] }
end

def itc_business_units
  # RTR is in SRG SSR ASC team
  business_units.map do |business_unit|
    business_unit == 'RTR' ? 'SRGSSR' : business_unit
  end
end

def itc_team_ids
  itc_business_units.map do |itc_business_unit|
    ENV["#{itc_business_unit}_ITUNES_CONNECT_TEAM_ID"]
  end
end

def itc_team_id_index(itc_team_id)
  itc_team_ids.index(itc_team_id)
end

# Returns current tag version
def tag_version(platform)
  "#{xcode_marketing_version(platform)}-#{xcode_build_number(platform)}"
end

def srg_tag(platform)
  "#{platform.downcase}/#{tag_version(platform)}"
end

def build_number_from_tag_version(tag_version)
  tag_version.split('-').last
end

def marketing_version_from_tag_version(tag_version)
  tag_version.split('-').first
end

# Returns the what's new text from WhatsNew-beta.json file in the repository
def what_s_new_for_beta(platform, tag_version)
  tag_version ||= tag_version(platform)

  json = what_s_new_for_beta_json(platform)
  what_s_new = json[tag_version]
  what_s_new || ''
end

def build_number_for_version(platform, version)
  json = what_s_new_for_beta_json(platform)
  tag_version = json.keys.select { |key| key.start_with?(version) }.last
  tag_version ? build_number_from_tag_version(tag_version) : '999999'
end

def what_s_new_for_beta_json(platform)
  file = File.open("../WhatsNew-#{platform}-beta.json", 'r')
  json = JSON.parse(file.read)
  file.close
  json
end

def release_notes_html_platform(platform)
  platform == 'iOS' ? 'iPhone & iPad' : 'Apple TV'
end

def release_notes_html(platform, business_unit, divs)
  input_file = "release_notes-#{business_unit.downcase}.html"
  html = File.read("gh-pages/releases/#{input_file}")
  html = html.gsub('<!-- platform -->', release_notes_html_platform(platform))
  html.sub('<!-- versions -->', divs.strip)
end

def release_notes_table_to_html_divs(platform, table, live_version)
  divs = ''
  table.map do |row|
    is_preprod = version_is_preprod(platform, row[0], live_version)
    divs += release_notes_version_to_html(platform, row[0], row[1], is_preprod)
  end
  divs.strip
end

def release_notes_version_to_html(platform, version, text, is_preprod)
  build_number = build_number_for_version(platform, version)
  attribute = is_preprod ? ' preprod' : ''
  div = "<div id=\"build_#{build_number}\"#{attribute}>\n<h2>#{version}</h2>\n"
  div += release_notes_to_html(text)
  div += "\n</div>\n"
  div
end

def version_is_preprod(platform, version, live_version)
  released_version = live_version.version_string
  released_build = live_version.build.version
  build_number = build_number_for_version(platform, version)

  version != released_version && build_number > released_build
end

def release_notes_to_html(text)
  output = ''
  in_list = false
  text.each_line.reject { |line| line.strip == '' }.map do |line|
    if line.start_with?('-')
      output += "<ul>\n" unless in_list
      in_list = true
      output += "<li>#{line[1..-1].strip}</li>\n"
    else
      output += "</ul>\n" if in_list
      in_list = false
      output += "<p>#{line.strip}</p>\n"
    end
  end
  output += '</ul>' if in_list
  output.strip
end

# Characters "-" or "+" in version are not allowed on App Store Connect.
def update_options_to_appstore(options)
  return options unless options[:export_to_appstore]

  options[:version_suffix] = ''
  version = options[:version]
  index = version.index('-')
  return options unless index

  options[:version] = version[0..index - 1]
  options
end

def srg_xcargs(options)
  xcargs = 'ENABLE_BITCODE=NO'
  xcargs += " BUNDLE_DISPLAY_NAME_SUFFIX='#{options[:display_name_suffix]}'"
  xcargs += " MARKETING_VERSION='#{options[:version]}'"
  xcargs += " MARKETING_VERSION_SUFFIX='#{options[:version_suffix]}'"
  xcargs += " BUILD_NAME='#{options[:build_name]}'"
  xcargs += " DEVELOPMENT_TEAM='#{options[:team_id]}'"
  xcargs + srg_xcargs_code_signing(options)
end

# Use cloud signing if available
def srg_xcargs_code_signing(options)
  export_to_appstore = options[:export_to_appstore] || false
  asc_api_key = srg_app_store_connect_api_key if export_to_appstore

  xcargs = ''
  if asc_api_key
    xcargs += " -authenticationKeyIssuerID '#{asc_api_key[:issuerId]}'"
    xcargs += " -authenticationKeyID '#{asc_api_key[:id]}'"
    xcargs += " -authenticationKeyPath '#{asc_api_key[:filePath]}'"
  end
  "#{xcargs} -allowProvisioningUpdates"
end

def nightly_display_name_suffix(branch_name)
  nightly_display_name_suffix = ' üåô'
  nightly_display_name_suffix = ' üåø' if branch_name.include? 'feature/'
  nightly_display_name_suffix
end

def nightly_version_suffix(branch_name)
  nightly_version_suffix = '-nightly'
  if branch_name.include? 'feature/'
    nightly_version_suffix += "+#{branch_name.sub('feature/', '').strip}"
  end
  nightly_version_suffix
end

def nightly_build_name(branch_name)
  if branch_name.include? 'feature/'
    branch_name.sub('feature/', '').strip
  else
    ''
  end
end

# Return a nightly changelog from git commit messages
def nightly_changelog(platform, service)
  last_commit_hash = last_nightlies_success_git_commit_hash(platform, service)
  last_commit_hash = 'HEAD^^^^^' if last_commit_hash.length < 12

  changelog = changelog_from_git_commits(
    between: [last_commit_hash, 'HEAD'],
    pretty: '- %s'
  )

  # HAX: strip emoji from changelog
  changelog = changelog ? changelog.sub(/[\u{1F300}-\u{1F6FF}]/, '').lstrip : ''

  changelog.empty? ? 'No change log found for this build.' : changelog
end

# Save the git commit hash in a local text file for nightlies
def save_last_nightlies_success_git_commit_hash(platform, service)
  last = last_git_commit
  platform = platform ? "#{platform.downcase}-" : ''
  service = service ? "#{service.downcase}-" : ''
  file_name = "last-#{service}#{platform}nightlies-success-git-commit-hash.txt"
  File.write(file_name, last[:commit_hash])
  last[:commit_hash]
end

# Read the git commit hash in a local text file for nightlies
def last_nightlies_success_git_commit_hash(platform, service)
  platform = platform ? "#{platform.downcase}-" : ''
  service = service ? "#{service.downcase}-" : ''
  file_name = "last-#{service}#{platform}nightlies-success-git-commit-hash.txt"
  file = File.open(file_name, 'a+')
  nightlies_success_git_commit_hash = file.read
  file.close
  nightlies_success_git_commit_hash
end

# Returns the marketing version for a platform, without suffix
def xcode_marketing_version(platform)
  get_xcconfig_value(
    path: srg_xcconfig_path(platform),
    name: 'MARKETING_VERSION'
  )
end

# Returns the build number for a platform
def xcode_build_number(platform)
  get_xcconfig_value(
    path: srg_xcconfig_path(platform),
    name: 'CURRENT_PROJECT_VERSION'
  )
end

# Override build number for a platform (current project version)
def xcode_override_build_number(platform, build_number)
  update_xcconfig_value(
    path: srg_xcconfig_path(platform),
    name: 'CURRENT_PROJECT_VERSION',
    value: build_number.to_s
  )
  build_number.to_s
end

def srg_xcconfig_path(platform)
  "Xcode/Shared/Targets/#{platform}/Common.xcconfig"
end

def appstore_platform(platform)
  appstore_platforms = { 'iOS' => 'ios', 'tvOS' => 'appletvos' }
  appstore_platforms[platform]
end

def srg_app_store_connect_api_key(business_unit = nil)
  business_unit ||= business_units[itc_team_id_index(app_config.try_fetch_value(:itc_team_id))]
  key_prefix = itc_business_units[business_unit_index(business_unit)]
  return unless key_prefix

  folder_path = Dir.chdir('..') { Dir.pwd }
  { id: ENV["#{key_prefix}_APPSTORE_CONNECT_API_KEY_ID"],
    issuerId: ENV["#{key_prefix}_APPSTORE_CONNECT_API_KEY_ISSUER_ID"],
    filePath: "#{folder_path}/Configuration/#{ENV["#{key_prefix}_APPSTORE_CONNECT_API_KEY_PATH"]}" }
end

def login_with_app_store_connect_api_key
  asc_api_key = srg_app_store_connect_api_key
  return unless asc_api_key

  app_store_connect_api_key(
    key_id: asc_api_key[:id],
    issuer_id: asc_api_key[:issuerId],
    key_filepath: asc_api_key[:filePath]
  )
end

def pilot_fast_upload(app_identifier, platform)
  app_identifier ||= app_config.try_fetch_value(:app_identifier)
  platform ||= 'iOS'

  lane_context.delete(SharedValues::FL_CHANGELOG)

  xcversion(version: '~> 13')
  login_with_app_store_connect_api_key
  pilot(
    app_identifier: app_identifier,
    app_platform: appstore_platform(platform),
    skip_waiting_for_build_processing: true
  )
  xcversion(version: '~> 14')
end

def pilot_distribute(app_identifier, platform, tag_version, changelog, is_public_beta)
  app_identifier ||= app_config.try_fetch_value(:app_identifier)
  platform ||= 'iOS'
  tag_version ||= tag_version(platform)
  is_public_beta ||= false

  xcversion(version: '~> 13')
  srg_pilot_distribute(app_identifier, platform, tag_version, changelog, is_public_beta)
  xcversion(version: '~> 14')
rescue StandardError => e
  xcversion(version: '~> 14')

  raise unless e.message.include? 'Another build is in review'

  UI.important 'Another build is already in TestFlight app review. Skipping external distribution. ‚ö†Ô∏è'
end

def srg_pilot_distribute(app_identifier, platform, tag_version, changelog, is_public_beta)
  groups = is_public_beta ? ENV['ITUNES_CONNECT_TF_PUBLIC_GROUPS'] : ENV['ITUNES_CONNECT_TF_GROUPS']

  login_with_app_store_connect_api_key
  pilot(
    distribute_only: true,
    app_identifier: app_identifier,
    app_platform: appstore_platform(platform),
    app_version: marketing_version_from_tag_version(tag_version),
    build_number: build_number_from_tag_version(tag_version),
    changelog: changelog,
    distribute_external: true,
    groups: groups,
    notify_external_testers: true,
    demo_account_required: false,
    beta_app_review_info: beta_app_review_info
  )
end

def upload_appcenter_dsyms(appcenter_appname)
  dsym = lane_context[SharedValues::DSYM_OUTPUT_PATH]
  appcenter_lane(
    appname: appcenter_appname,
    notes: 'DSYMs from local build (via fastlane).',
    upload_dsym: dsym
  )
  lane_context.delete(SharedValues::DSYM_OUTPUT_PATH)
end

# Share build version and number to the continuous integration
def notify_version_to_ci(platform, tag_version, build_name)
  return unless ENV['TEAMCITY_VERSION']

  platform ||= iOS
  tag_version ||= tag_version(platform)
  build_name ||= ''

  displayed_build_number = tag_version
  displayed_build_number += "+#{build_name}" unless build_name.empty?
  puts "##teamcity[buildNumber '#{displayed_build_number}']"
end

# Returns current build number on App Center
def latest_appcenter_build_number(app_names)
  build_number = 0
  app_names.each_index do |index|
    number = Integer(appcenter_fetch_version_number(
      api_token: ENV['PLAY_APPCENTER_TOKEN'],
      owner_name: ENV['PLAY_APPCENTER_OWNER'],
      app_name: app_names[index]
    )['build_number'])

    build_number = number unless build_number >= number
  end
  build_number
end

# Returns current build number on App Store Connect
def srg_latest_testflight_build_number(app_identifiers, platform)
  login_with_app_store_connect_api_key

  build_number = 0
  app_identifiers.each_index do |index|
    number = latest_testflight_build_number(
      platform: appstore_platform(platform),
      app_identifier: app_identifiers[index]
    )

    build_number = number unless build_number >= number
  end
  build_number
end

# Create screenshots for App Store Connect.
def screenshots(platform, business_unit)
  platform ||= 'iOS'
  output_directory = "fastlane/export/#{lane_context[SharedValues::LANE_NAME]}"
  Dir.chdir('..') { FileUtils.mkdir_p(output_directory) }

  snapshot(
    scheme: screenshots_scheme(platform, business_unit),
    languages: [device_language(business_unit)],
    devices: snapshot_devices(platform),
    derived_data_path: derived_data_path,
    output_directory: output_directory
  )
end

def device_language(business_unit)
  languages = {
    'RSI' => 'it-CH',
    'RTR' => 'de-CH',
    'RTS' => 'fr-CH',
    'SRF' => 'de-CH',
    'SWI' => 'en-US'
  }
  languages[business_unit]
end

def upload_screenshots(platform)
  platform ||= 'iOS'

  login_with_app_store_connect_api_key
  deliver(
    platform: appstore_platform(platform),
    app_version: xcode_marketing_version(platform),
    skip_binary_upload: true,
    skip_metadata: true,
    overwrite_screenshots: true,
    precheck_include_in_app_purchases: false,
    force: true # Don't stop to wait manual preview
  )
end

def can_upload_testflight_build(app_identifier, platform, tag_version)
  app_identifier ||= app_config.try_fetch_value(:app_identifier)
  platform ||= 'iOS'
  tag_version ||= tag_version(platform)
  build_number = build_number_from_tag_version(tag_version)

  login_with_app_store_connect_api_key
  appstore_build_number = latest_testflight_build_number(
    platform: appstore_platform(platform),
    app_identifier: app_identifier
  )

  (appstore_build_number < build_number.to_i)
end

def prepare_appstore_release(platform, business_unit, options)
  platform ||= 'iOS'
  tag_version = options[:tag_version] || tag_version(platform)
  submit_for_review = options[:submit_for_review] || false

  metadata_path = appstore_release_metadata_path(platform, business_unit, tag_version)

  srg_deliver(platform, tag_version, metadata_path, submit_for_review)
end

def srg_deliver(platform, tag_version, metadata_path, submit_for_review)
  login_with_app_store_connect_api_key
  deliver(
    platform: appstore_platform(platform),
    app_version: marketing_version_from_tag_version(tag_version),
    build_number: build_number_from_tag_version(tag_version),
    skip_binary_upload: true,
    skip_screenshots: true,
    metadata_path: metadata_path,
    precheck_include_in_app_purchases: false,
    submit_for_review: submit_for_review,
    submission_information: { add_id_info_uses_idfa: false },
    automatic_release: true,
    force: true # Don't stop to wait manual preview
  )
end

def appstore_release_metadata_path(platform, business_unit, tag_version)
  platform ||= 'iOS'
  tag_version ||= tag_version(platform)

  # Erase previous metadata
  output_directory = "fastlane/export/#{lane_context[SharedValues::LANE_NAME]}"
  metadata_directory = "#{output_directory}/metadata"
  Dir.chdir('..') { FileUtils.remove_entry(metadata_directory, true) }

  language_directory = "#{metadata_directory}/#{appstore_language(business_unit)}"
  Dir.chdir('..') { FileUtils.mkdir_p(language_directory) }

  collect_appstore_release_notes(platform, business_unit, language_directory, tag_version)

  metadata_directory
end

def appstore_language(business_unit)
  languages = {
    'RSI' => 'it',
    'RTR' => 'de-DE',
    'RTS' => 'fr-FR',
    'SRF' => 'de-DE',
    'SWI' => 'en-US'
  }
  languages[business_unit]
end

def collect_appstore_release_notes(platform, business_unit, language_directory, tag_version)
  marketing_version = marketing_version_from_tag_version(tag_version)
  release_notes = get_appstore_release_notes(platform, business_unit, marketing_version)
  file_name = 'release_notes.txt'
  Dir.chdir("../#{language_directory}") { File.write(file_name, release_notes) }
  UI.important "Release notes for Play #{business_unit} #{platform} #{marketing_version}:\n#{release_notes}"
end

def major_version(platform)
  platform == 'iOS' ? 3 : 1
end

def release_notes_table_for_html(platform, business_unit)
  table = get_appstore_release_notes_table(platform, business_unit).reverse
  table.select { |row| row[0].start_with?(major_version(platform).to_s) }
end

def get_appstore_release_notes(platform, business_unit, marketing_version)
  table = get_appstore_release_notes_table(platform, business_unit)

  index = table.by_col[0].find_index(marketing_version)
  release_notes = table.by_col[1][index] if index

  UI.user_error! "On Crowdin, #{file_name} for #{business_unit} has no release notes for #{marketing_version} version." unless release_notes

  release_notes
end

def get_appstore_release_notes_table(platform, business_unit)
  file_name = "What_s new #{platform}.csv"
  file_path = "/tmp/playsrg-crowdin/#{crowdin_language(business_unit)}/Apple/Play App/#{file_name}"
  CSV.read(file_path)
end

def crowdin_language(business_unit)
  languages = {
    'RSI' => 'it-CH',
    'RTR' => 'rm-CH',
    'RTS' => 'fr-CH',
    'SRF' => 'de-CH',
    'SWI' => 'en'
  }
  languages[business_unit]
end

def pull_translations_lane_condition(lane)
  lane.to_s.downcase.include? 'release'
end

def skip_pull_translations
  ENV['CROWDIN_TRANSLATIONS_PULLLED'] == '1'
end

def pull_translations
  Dir.chdir('..') { sh 'Configuration/Scripts/pullCrowdin.sh --skip-copies' }
  ENV['CROWDIN_TRANSLATIONS_PULLLED'] = '1'
end

# Beta workflow: tag the new beta, bump build number and push to the repository,
# only if we are on the develop branch and the tag does not already exist.
def bump_build_number_beta_workflow(platform)
  return unless git_branch_name.include? 'develop'

  tag = srg_tag(platform)

  git_pull(only_tags: true)
  if git_tag_exists(tag: tag)
    UI.important "Tag \"#{tag}\" already exists. Probably done by an other build (to AppCenter, to TestFlight or did it manually). ‚ö†Ô∏è"
  else
    srg_add_tag_and_bump_build_number(platform, tag)
    UI.message "Tag \"#{tag}\" created. ‚úÖ"
  end
end

def srg_add_tag_and_bump_build_number(platform, tag)
  add_git_tag(tag: tag)
  bump_build_number_commit(platform)
  git_pull(rebase: true)
  push_to_git_remote
end

def bump_build_number_commit(platform)
  build_number = xcode_override_build_number(platform, xcode_build_number(platform).to_i + 1)
  commit_version_bump(
    xcodeproj: 'PlaySRG.xcodeproj',
    message: "Bump #{platform} build number to #{build_number}",
    include: srg_xcconfig_path(platform),
    ignore: /.+/
  )
end

def git_branch_name
  sh "git branch | grep \\* | cut -d ' ' -f2"
end

def beta_app_review_info
  {
    contact_email: ENV['ITUNES_CONNECT_REVIEW_EMAIL'],
    contact_first_name: ENV['ITUNES_CONNECT_REVIEW_FIRST_NAME'],
    contact_last_name: ENV['ITUNES_CONNECT_REVIEW_LAST_NAME'],
    contact_phone: ENV['ITUNES_CONNECT_REVIEW_PHONE']
  }
end

def snapshot_devices(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    snapshot_ios_devices
  else
    snapshot_tvos_devices
  end
end

def snapshot_ios_devices
  [
    'iPhone 13 Pro Max', # 6.5 inch, required
    'iPhone 8 Plus', # 5.5 inch, required
    'iPad Pro (12.9-inch) (5th generation)', # 12.9 inch, required
    'iPad Pro (12.9-inch) (2nd generation)' # 12.9 inch, required
  ]
end

def snapshot_tvos_devices
  [
    'Apple TV'
  ]
end

def spaceship_login
  ENV['FASTLANE_ITC_TEAM_ID'] = app_config.try_fetch_value(:itc_team_id)
  Spaceship::Tunes.login
  Spaceship::Tunes.select_team
end

def spaceship_login_with_api_key(business_unit = nil)
  asc_api_key = srg_app_store_connect_api_key(business_unit)
  return unless asc_api_key

  token = Spaceship::ConnectAPI::Token.create(
    key_id: asc_api_key[:id],
    issuer_id: asc_api_key[:issuerId],
    filepath: asc_api_key[:filePath]
  )

  Spaceship::ConnectAPI.token = token
end

def spaceship_platform(platform)
  spaceship_platforms = { 'iOS' => 'IOS', 'tvOS' => 'TV_OS' }
  spaceship_platforms[platform]
end

def spaceship_email_required(email)
  return if !email || (email.strip !~ URI::MailTo::EMAIL_REGEXP)

  email.strip
end

def spaceship_bu_appstore_build_app(business_unit)
  app_identifier = appstore_build_identifiers[business_unit_index(business_unit)]
  spaceship_app(app_identifier)
end

def spaceship_app(app_identifier)
  app = Spaceship::ConnectAPI::App.find(app_identifier)
  UI.important "#{app_identifier} app does not exist. ‚ö†Ô∏è" unless app
  app
end

def spaceship_get_group(app, group_name)
  group = app.get_beta_groups(filter: { name: group_name }).first
  UI.important "#{group_name} group does not exist for #{app.name}. ‚ö†Ô∏è" unless group
  group
end

def spaceship_get_tester(app, email)
  Spaceship::TestFlight::Tester.search(app_id: app.id, text: email).first
end

def spaceship_delete_tester(app, tester)
  Spaceship::ConnectAPI.delete_beta_tester_from_apps(
    beta_tester_id: tester.tester_id,
    app_ids: [app.id]
  )
end

def spaceship_new_tester(email, first_name, last_name)
  { email: email, firstName: first_name, lastName: last_name }
end

def spaceship_add_tester(group, email, first_name, last_name)
  tester = spaceship_new_tester(email, first_name, last_name)
  group.post_bulk_beta_tester_assignments(beta_testers: [tester])
end

def spaceship_app_live_version(platform, app)
  app.get_live_app_store_version(platform: spaceship_platform(platform))
end

def spaceship_app_latest_known_version(platform, app)
  app.get_latest_app_store_version(platform: spaceship_platform(platform))
end

def publish_on_github_pages(output_directory, releases_directory)
  branch_name = git_branch_name

  Dir.chdir('..') do
    sh 'git checkout --orphan gh-pages'
    sh 'git reset --hard'
    sh "mv \"#{output_directory}/index.html\" ./"
    sh 'git add index.html'
    sh "mv \"#{releases_directory}\" ./"
    sh 'git add releases/*'
    sh 'git commit -m "Publish release notes"'
    sh 'git push origin gh-pages --force'
    sh "git checkout #{branch_name}"
    sh 'git branch -D gh-pages'
  end
end

# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md

# fastlane reports which actions are used
# No personal data is recorded. Learn more at https://github.com/fastlane/enhancer
