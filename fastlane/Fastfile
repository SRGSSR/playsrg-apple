# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version "2.96.0"

default_platform :ios

platform :ios do

  before_all do |lane|

    # For betas, before all, check if we have a beta release description
    if lane.to_s == "betas"
      build_number = get_build_number
      marketing_version = getMarketingVersion
      tag_version = marketing_version + '-' + build_number

      whatsNewForBeta = getWhatsNewForBeta(tag_version: tag_version)
      if whatsNewForBeta.empty?
        UI.user_error!("Woops, there is no beta release note in the WhatsNew-beta.json file for " + tag_version)
      end
    end

    if (lane.to_s != "devLane") && (!lane.to_s.downcase.include? "dsym")
      ensure_git_status_clean
      Dir.chdir("..") do
        sh "make bootstrap"
      end
    end
  end

  desc "For each BUs, build a new nightly on App Center, with a new build number, greater than the old nightly build number"
  lane :nightlies do

    schemes = ["Play SWI", "Play RTS", "Play SRF", "Play RSI", "Play RTR"]
    appcenter_nightly_names = [ENV['PLAY_SWI_NIGHTLY_APPCENTER_APPNAME'], ENV['PLAY_RTS_NIGHTLY_APPCENTER_APPNAME'], ENV['PLAY_SRF_NIGHTLY_APPCENTER_APPNAME'], ENV['PLAY_RSI_NIGHTLY_APPCENTER_APPNAME'], ENV['PLAY_RTR_NIGHTLY_APPCENTER_APPNAME']]

    appCenterBuildNumber = getAppCenterBuildNumber
    increment_build_number(
      build_number: appCenterBuildNumber + 1
    )

    notify_build_number_to_ci

    changelog = default_changelog_for_nightlies

    branch_name = sh "git branch | grep \\* | cut -d ' ' -f2"

    bundle_display_name_suffix = " ðŸŒ™"
    marketing_version_suffix = "-nightly"
    if (branch_name.include? 'feature/')
    	bundle_display_name_suffix = " ðŸŒ¿"
    	marketing_version_suffix = marketing_version_suffix + '+' + branch_name.sub('feature/', '').strip
    end

    schemes.each_index do |index|

      build_lane(
        configuration: "Nightly",
        scheme: schemes[index],
        bundle_display_name_suffix: bundle_display_name_suffix,
        marketing_version_suffix: marketing_version_suffix
      )

      appcenter_lane(
        appname: appcenter_nightly_names[index],
        destinations: ENV['PLAY_NIGHTLY_APPCENTER_DESTINATIONS'],
        notes: changelog
      )

      clean_build_artifacts

    end

    saveLastNightliesSuccessGitCommitHash

  end

  desc "For each BUs, build a new beta on App Center with the current build number. If we're not in a release or hotfix process (master, release/* or hotfix/*), tag the current version on the repository and bump the build number"
  lane :betas do

    schemes = ["Play SWI", "Play RTS", "Play SRF", "Play RSI", "Play RTR"]
    appcenter_beta_names = [ENV['PLAY_SWI_BETA_APPCENTER_APPNAME'], ENV['PLAY_RTS_BETA_APPCENTER_APPNAME'], ENV['PLAY_SRF_BETA_APPCENTER_APPNAME'], ENV['PLAY_RSI_BETA_APPCENTER_APPNAME'], ENV['PLAY_RTR_BETA_APPCENTER_APPNAME']]

    build_number = get_build_number
    marketing_version = getMarketingVersion
    tag_version = marketing_version + '-' + build_number

    notify_build_number_to_ci

    whatsNewForBeta = getWhatsNewForBeta(tag_version: tag_version)

    schemes.each_index do |index|

      build_lane(
        configuration: "Beta",
        scheme: schemes[index],
        bundle_display_name_suffix: " ðŸŽ¯",
        marketing_version_suffix: "-beta"
      )

      appcenter_lane(
        appname: appcenter_beta_names[index],
        destinations: ENV['PLAY_BETA_APPCENTER_DESTINATIONS'],
        notes: whatsNewForBeta,
        notify_testers: true
      )

      clean_build_artifacts

    end

    #Tag the new beta, bump build number and push to the repo only if we're not in a release process
    
    branch_name = sh "git branch | grep \\* | cut -d ' ' -f2"
    is_in_release_process = (branch_name.include? 'master') || (branch_name.include? 'release') || (branch_name.include? 'hotfix')

    if ! is_in_release_process
      add_git_tag tag: tag_version

      build_number = increment_build_number
      commit_version_bump(
        xcodeproj: "PlaySRG.xcodeproj",
        message: "Bump build number to " + build_number,
        ignore: /.+/
      )
      push_to_git_remote
    end

  end

  desc "SWI: Upload a new build (bitcode) on AppStore Connect with the current build number."
  lane :swiAppStoreUpload do
    testflight_lane(
      scheme: "Play SWI"
    )
  end

  desc "SRF: Upload a new build (bitcode) on AppStore Connect with the current build number."
  lane :srfAppStoreUpload do
    testflight_lane(
      scheme: "Play SRF"
    )
  end

  desc "RTS: Upload a new build (bitcode) on AppStore Connect with the current build number."
  lane :rtsAppStoreUpload do
    testflight_lane(
      scheme: "Play RTS"
    )
  end

  desc "RSI: Upload a new build (bitcode) on AppStore Connect with the current build number."
  lane :rsiAppStoreUpload do
    testflight_lane(
      scheme: "Play RSI"
    )
  end

  desc "RTR: Upload a new build (bitcode) on AppStore Connect with the current build number."
  lane :rtrAppStoreUpload do
    testflight_lane(
      scheme: "Play RTR"
    )
  end

  desc "Send latest dSYMs to App Center. Optional 'version' or 'min_version' parameters."
  lane :dSYMs do |options|
    min_version = options[:min_version]
    version = options[:version]

    options = '';
    if min_version
      options += ' min_version:' + min_version
    end
    if version
      options += ' version:' + version
    end

    sh 'bundle exec fastlane ios swiDSYMs' + options
    sh 'bundle exec fastlane ios srfDSYMs' + options
    sh 'bundle exec fastlane ios rtsDSYMs' + options
    sh 'bundle exec fastlane ios rsiDSYMs' + options
    sh 'bundle exec fastlane ios rtrDSYMs' + options
  end

  desc "SWI: Send latest dSYMs to App Center, with same parameters."
  lane :swiDSYMs do |options|
    updateDSYMs(options, ENV['PLAY_SWI_APPSTORE_APPCENTER_APPNAME'])
  end

  desc "SFR: Send latest dSYMs to App Center, with same parameters."
  lane :srfDSYMs do |options|
    updateDSYMs(options, ENV['PLAY_SRF_APPSTORE_APPCENTER_APPNAME'])
  end

  desc "RTS: Send latest dSYMs to App Center, with same parameters."
  lane :rtsDSYMs do |options|
    updateDSYMs(options, ENV['PLAY_RTS_APPSTORE_APPCENTER_APPNAME'])
  end

  desc "RSI: Send latest dSYMs to App Center, with same parameters."
  lane :rsiDSYMs do |options|
    updateDSYMs(options, ENV['PLAY_RSI_APPSTORE_APPCENTER_APPNAME'])
  end

  desc "RTR: Send latest dSYMs to App Center, with same parameters."
  lane :rtrDSYMs do |options|
    updateDSYMs(options, ENV['PLAY_RTR_APPSTORE_APPCENTER_APPNAME'])
  end

  desc "Build, upload to TestFlight"
  private_lane :testflight_lane do |options|
    scheme = options[:scheme]

    build_lane(
      configuration: "AppStore",
      scheme: scheme,
      export_to_appstore: true
    )

    pilot(
      skip_waiting_for_build_processing: true
    )

    clean_build_artifacts
  end

  desc "Build for a scheme and a configuration"
  private_lane :build_lane do |options|
    scheme = options[:scheme]
    configuration = options[:configuration]
    export_to_appstore = options[:export_to_appstore] ? options[:export_to_appstore] : false
    bundle_display_name_suffix = options[:bundle_display_name_suffix] ? options[:bundle_display_name_suffix] : ""
    marketing_version_suffix = options[:marketing_version_suffix] ? options[:marketing_version_suffix] : ""

    output_directory = 'fastlane/export/' + lane_context[SharedValues::LANE_NAME] + '/'

    team_id = CredentialsManager::AppfileConfig.try_fetch_value(:team_id)

    enable_bitcode_arg = export_to_appstore ? "ENABLE_BITCODE=YES" : "ENABLE_BITCODE=NO"
    xcargs = enable_bitcode_arg + ' BUNDLE_DISPLAY_NAME_SUFFIX="' + bundle_display_name_suffix + '" MARKETING_VERSION_SUFFIX="' + marketing_version_suffix + '" DEVELOPMENT_TEAM="' + team_id + '" -allowProvisioningUpdates'
    
    gym(
      configuration: configuration,
      scheme: scheme,
      silent: true,
      clean: true,
      xcargs: xcargs,
      export_method: export_to_appstore ? "app-store" : "enterprise",
      include_bitcode: export_to_appstore,
      export_team_id: team_id,
      output_directory: output_directory
    )
  end

  desc "Upload a build on App Center"
  private_lane :appcenter_lane do |options|
    appname = options[:appname]
    destinations = options[:destinations]
    notes = options[:notes]
    notify_testers = options[:notify_testers] ? options[:notify_testers] : false
    upload_dsym = options[:upload_dsym]

    if upload_dsym
      appcenter_upload(
        api_token: ENV['PLAY_APPCENTER_TOKEN'],
        owner_type: "organization",
        owner_name: ENV['PLAY_APPCENTER_OWNER'],
        app_name: appname,
        release_notes: notes,
        upload_dsym_only: true,
        dsym: upload_dsym
      )
    else
      appcenter_upload(
        api_token: ENV['PLAY_APPCENTER_TOKEN'],
        owner_type: "organization",
        owner_name: ENV['PLAY_APPCENTER_OWNER'],
        app_name: appname,
        release_notes: notes,
        destination_type: "group",
        destinations: destinations,
        notify_testers: notify_testers,
      )
    end
  end

  desc "Returns a default changelog for nightlies"
  private_lane :default_changelog_for_nightlies do

    lastNightliesGitCommitHash = getLastNightliesSuccessGitCommitHash
    if lastNightliesGitCommitHash.length < 12
      lastNightliesGitCommitHash = "HEAD^^^^^"
    end

    changelog = changelog_from_git_commits(
        between: [lastNightliesGitCommitHash, "HEAD"],
        pretty: "- %s"
    )
    # HAX: strip emoji from changelog
    changelog = (changelog) ? changelog.sub(/[\u{1F300}-\u{1F6FF}]/, '') : "No change log found for this build."
    Actions.lane_context[SharedValues::FL_CHANGELOG] = changelog
    changelog
  end

  desc "Return current build number on App Center"
  private_lane :getAppCenterBuildNumber do
    appCenterBuildNumber = (sh "scripts/appcenter-build-number.sh -t #{ENV['PLAY_APPCENTER_TOKEN']} #{ENV['PLAY_SWI_NIGHTLY_APPCENTER_SECRET']} #{ENV['PLAY_RTS_NIGHTLY_APPCENTER_SECRET']} #{ENV['PLAY_SRF_NIGHTLY_APPCENTER_SECRET']} #{ENV['PLAY_RSI_NIGHTLY_APPCENTER_SECRET']} #{ENV['PLAY_RTR_NIGHTLY_APPCENTER_SECRET']}")
    appCenterBuildNumber = Integer(appCenterBuildNumber.lines.map(&:chomp).last)
    appCenterBuildNumber
  end

  desc "Save the git commit hash in a local text file for nightlies"
  private_lane :saveLastNightliesSuccessGitCommitHash do
    last = last_git_commit
    File.open("last-nightlies-success-git-commit-hash.txt", 'w') {|f| f.write(last[:commit_hash]) }
    last[:commit_hash]
  end

  desc "Read the git commit hash in a local text file for nightlies"
  private_lane :getLastNightliesSuccessGitCommitHash do
    file = File.open("last-nightlies-success-git-commit-hash.txt", "a+")
    lastNightliesSuccessGitCommitHash = file.read
    file.close
    lastNightliesSuccessGitCommitHash
  end

  desc "Return the marketing version, without suffix"
  private_lane :getMarketingVersion do
     marketing_version = sh 'cd ..; xcodebuild -showBuildSettings | grep "MARKETING_VERSION =" | tr -d " =" | sed "s/MARKETING_VERSION//"'
     marketing_version = marketing_version.lines.last.gsub(/\s+/, "")
     marketing_version
  end

  desc "Return the bundle app identifier"
  private_lane :getAppIdentifier do |options|
     app_identifier = sh 'cd ..; xcodebuild -scheme "' + options[:scheme] + '" -configuration "' + options[:configuration] + '" -showBuildSettings | grep "PRODUCT_BUNDLE_IDENTIFIER =" | tr -d " =" | sed "s/PRODUCT_BUNDLE_IDENTIFIER//"'
     app_identifier = app_identifier.lines.last.gsub(/\s+/, "")
     app_identifier
  end

  desc "Return the what's new text from WhatsNew-Beta.json file in the repository"
  private_lane :getWhatsNewForBeta do |options|
    tag_version = options[:tag_version]
    file = File.open("../WhatsNew-beta.json", "r")  
    json = JSON.parse(file.read)
    file.close
    whatsNew = json[tag_version]
    whatsNew ? whatsNew : ''
  end

  # desc "A dev lane to test ruby scripts"
  # lane :devLane do
  #   build_number = increment_build_number
  #   commit_version_bump(
  #       xcodeproj: "PlaySRG.xcodeproj",
  #       message: "Bump build number to " + build_number,
  #       ignore: /.+/
  #   )
  # end

  # Share build number to the continus integration
  def notify_build_number_to_ci
    return unless ENV['TEAMCITY_VERSION']

    displayed_build_number = getMarketingVersion + '-' + get_build_number
    puts '##teamcity[buildNumber \'' + displayed_build_number + + '\']'
  end

  def updateDSYMs (options, appcenter_app_name)
    min_version = options[:min_version]
    version = options[:version]

    output_directory = 'fastlane/export/' + lane_context[SharedValues::LANE_NAME]
    
    Dir.chdir("..") do
      FileUtils.mkdir_p(output_directory) if !File.directory?(output_directory)
    end

    if min_version
      download_dsyms(min_version: min_version, output_directory: output_directory)
    elsif version
      download_dsyms(version: version, output_directory: output_directory)
    else
      download_dsyms(version: "latest", output_directory: output_directory)
    end

    if lane_context[SharedValues::DSYM_PATHS]
      lane_context[SharedValues::DSYM_PATHS].each { |dSYM|
        appcenter_lane(
          appname: appcenter_app_name,
          notes: 'DSYMs from AppStore Connect (via fastlane).',
          upload_dsym: dSYM
        )
      }
    end

    clean_build_artifacts
  end

  after_all do |lane|
    if (lane.to_s != "devLane") && (!lane.to_s.downcase.include? "dsym")
      reset_git_repo(skip_clean: true)
    end

    # slack(
    #   message: "Successfully deployed new App Update."
    # )
  end

  error do |lane, exception|
    if (lane.to_s != "devLane") && (!lane.to_s.downcase.include? "dsym")
      clean_build_artifacts
      reset_git_repo(skip_clean: true, force: true)
    end

    # slack(
    #   message: exception.message,
    #   success: false
    # )
  end
end

# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md

# fastlane reports which actions are used
# No personal data is recorded. Learn more at https://github.com/fastlane/enhancer
