# frozen_string_literal: true

# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# If you want to automatically update fastlane if a new version is available:
# update_fastlane

# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version '2.210.1'

default_platform :ios

platform :ios do
  before_all do |lane, options|
    platform = platform(lane)
    tag_version = tag_version_from_options(options) || tag_version(platform)
    branch_name = git_branch_name

    notify_version_to_ci(platform, tag_version, branch_name) if notify_ci_condition(lane)

    create_or_update_github_environment(lane)
    create_github_deployment(lane)
    update_github_deployment_in_progress(lane)

    if what_s_new_condition(lane)
      what_s_new = what_s_new_for_beta(platform, tag_version)
      if what_s_new.empty?
        UI.user_error! "#{what_s_new_beta_file_name(platform)} has no release notes for #{tag_version}."
      end
    end

    # Use .xcode-version file
    xcodes(select_for_current_build_only: true)

    if cleaned_lane_condition(lane)
      ensure_git_status_clean(show_uncommitted_changes: true, show_diff: true)
      clean_derived_data unless skip_clean_derived_data
    end

    pull_translations unless !pull_translations_lane_condition(lane) || skip_pull_translations
  end

  #
  # Public lanes
  #

  # Nightlies

  desc 'Builds a new tvOS nightly on App Store Connect and waits for build processing.'
  lane :tvOSnightlies do
    testflight_nightlies(platform: 'tvOS')
  end

  desc 'Builds a new iOS nightly on App Store Connect and waits for build processing.'
  lane :iOSnightlies do
    testflight_nightlies(platform: 'iOS')
  end

  desc 'Adds a nightly TestFlight tester (email required)'
  lane :nightlyTester do |options|
    addTestFlightTester(
      email: options[:email],
      first_name: options[:first_name],
      last_name: options[:last_name],
      app_identifiers: appstore_nightly_identifiers,
      group_name: ENV.fetch('ITUNES_CONNECT_TF_GROUPS', nil)
    )
  end

  # Betas

  desc 'Builds a tvOS beta on App Store Connect with the current build number and waits for build processing. On the main branch, attempts to tag the current version. On the main or a branch, then bumps the build number and pushes. On a branch, try to report the new build number to main branch.'
  lane :tvOSbetas do
    testflight_betas(platform: 'tvOS')
  end

  desc 'Builds an iOS beta on App Store Connect with the current build number and waits for build processing. On the main branch, attempts to tag the current version. On the main or a branch, then bumps the build number and pushes. On a branch, try to report the new build number to main branch.'
  lane :iOSbetas do
    testflight_betas(platform: 'iOS')
  end

  desc 'Adds a beta TestFlight tester (email required)'
  lane :betaTester do |options|
    addTestFlightTester(
      email: options[:email],
      first_name: options[:first_name],
      last_name: options[:last_name],
      app_identifiers: appstore_beta_identifiers,
      group_name: ENV.fetch('ITUNES_CONNECT_TF_GROUPS', nil)
    )
  end

  # App Store builds

  desc 'Applies iOSUploadAppStoreBuilds and iOSDistributeAppStoreBuilds. Optional `public_beta_distribution` parameter, default value is `true`.'
  lane :iOSAppStoreBuilds do |options|
    public_beta_distribution = options[:public_beta_distribution] || true

    UI.important "The iOS AppStore build will be distributed to the #{groups_string(public_beta_distribution)}."

    new_options = ''
    new_options += " public_beta_distribution:#{public_beta_distribution}"

    sh 'bundle exec fastlane ios iOSUploadAppStoreBuilds'
    sh "bundle exec fastlane ios iOSDistributeAppStoreBuilds#{new_options}"
  end

  desc 'Uploads an iOS App Store build on App Store Connect with the current build number.'
  lane :iOSUploadAppStoreBuilds do
    business_units.map do |business_unit|
      sh "bundle exec fastlane ios iOS#{business_unit.downcase}UploadAppStoreBuild"
    end
  end

  desc 'Distributes to TestFlight groups an iOS App Store build on App Store Connect with the current version and build numbers. Optional `tag_version` parameter (`X.Y.Z-build_number`). Optional `public_beta_distribution` parameter, default value is `true`.'
  lane :iOSDistributeAppStoreBuilds do |options|
    tag_version = options[:tag_version]
    public_beta_distribution = options[:public_beta_distribution] || true

    new_options = ''
    new_options += " public_beta_distribution:#{public_beta_distribution}"
    new_options += " tag_version:#{tag_version}" if tag_version

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios iOS#{business_unit}DistributeAppStoreBuild#{new_options}"
    end
  end

  desc 'Applies tvOSUploadAppStoreBuilds and tvOSDistributeAppStoreBuilds. Optional `public_beta_distribution` parameter, default value is `true`.'
  lane :tvOSAppStoreBuilds do |options|
    public_beta_distribution = options[:public_beta_distribution] || true

    UI.important "The tvOS AppStore build will be distributed to the #{groups_string(public_beta_distribution)}."

    new_options = ''
    new_options += " public_beta_distribution:#{public_beta_distribution}"

    sh 'bundle exec fastlane ios tvOSUploadAppStoreBuilds'
    sh "bundle exec fastlane ios tvOSDistributeAppStoreBuilds#{new_options}"
  end

  desc 'Uploads a tvOS build on App Store Connect with the current build number.'
  lane :tvOSUploadAppStoreBuilds do
    business_units.map do |business_unit|
      sh "bundle exec fastlane ios tvOS#{business_unit.downcase}UploadAppStoreBuild"
    end
  end

  desc 'Distributes to TestFlight groups a tvOS App Store build on App Store Connect with the current version and build numbers. Optional `tag_version` parameter (`X.Y.Z-build_number`). Optional `public_beta_distribution` parameter, default value is `true`.'
  lane :tvOSDistributeAppStoreBuilds do |options|
    tag_version = options[:tag_version]
    public_beta_distribution = options[:public_beta_distribution] || true

    new_options = ''
    new_options += " public_beta_distribution:#{public_beta_distribution}"
    new_options += " tag_version:#{tag_version}" if tag_version

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios tvOS#{business_unit}DistributeAppStoreBuild#{new_options}"
    end
  end

  # Github deployments

  desc 'Stop unfinished Github deployments for a lane on the current git branch. Recommended `lane` parameter.'
  lane :stopUnfinishedGithubDeployments do |options|
    lane_name = options[:lane]

    UI.message 'Github environment is deducted from the lane name and the current git branch name.' unless lane_name
    lane_name ||= prompt(text: 'lane: ')

    stop_unfinished_github_deployments(lane_name)
  end

  # App Store reviews and releases

  desc 'Prepare AppStore iOS releases on App Store Connect with the current version and build numbers. No build uploads. Optional `tag_version` (`X.Y.Z-build_number`) or `submit_for_review` (boolean) parameters.'
  lane :iOSPrepareAppStoreReleases do |options|
    tag_version = options[:tag_version]
    submit_for_review = options[:submit_for_review]

    new_options = ''
    new_options += " tag_version:#{tag_version}" if tag_version
    new_options += " submit_for_review:#{submit_for_review}" if submit_for_review

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios iOS#{business_unit}PrepareAppStoreRelease#{new_options}"
    end
  end

  desc 'Prepare AppStore tvOS releases on App Store Connect with the current version and build numbers. No build uploads. Optional `tag_version` (`X.Y.Z-build_number`) or `submit_for_review` (boolean) parameters.'
  lane :tvOSPrepareAppStoreReleases do |options|
    tag_version = options[:tag_version]
    submit_for_review = options[:submit_for_review]

    new_options = ''
    new_options += " tag_version:#{tag_version}" if tag_version
    new_options += " submit_for_review:#{submit_for_review}" if submit_for_review

    business_units.map do |business_unit|
      business_unit = business_unit.downcase
      sh "bundle exec fastlane ios tvOS#{business_unit}PrepareAppStoreRelease#{new_options}"
    end
  end

  # App Store App status

  desc 'Get AppStore App status for iOS and tvOS. Optional `github_deployments` (boolean) and `publish_release_notes` (boolean) parameters.'
  lane :appStoreAppStatus do |options|
    github_deployments = options[:github_deployments] || false
    publish_release_notes = options[:publish_release_notes] || false
    new_live_version_found = false

    UI.message '-----'
    business_units.map do |business_unit|
      spaceship_login_with_api_key(business_unit)
      app = spaceship_bu_appstore_build_app(business_unit)
      next unless app

      UI.message '-----'
      UI.command_output "Switch to Play #{business_unit}"

      UI.message '-----'
      ['iOS', 'tvOS'].map do |platform|
        live_version = spaceship_app_live_version(platform, app)
        UI.success "Play #{business_unit} #{platform} live version #{live_version.version_string} (#{live_version.build.version}) is #{live_version.app_store_state}." if live_version
        UI.important "Play #{business_unit} #{platform} has no live version." unless live_version

        if github_deployments
          state = appstore_github_deployment(business_unit, platform, live_version)
          new_live_version_found ||= state == 'success' if state
        end

        latest_version = spaceship_app_latest_known_version(platform, app)
        if !latest_version || latest_version.version_string == live_version.version_string
          UI.success "Play #{business_unit} #{platform} version #{live_version.version_string} (#{live_version.build.version}) is the latest one."
        else
          build_version = latest_version.build ? latest_version.build.version : 'NaN'
          UI.important "Play #{business_unit} #{platform} latest version #{latest_version.version_string} (#{build_version}) is #{latest_version.app_store_state}."

          appstore_github_deployment(business_unit, platform, latest_version) if github_deployments
        end
        version_localization = spaceship_app_version_localization(latest_version)
        UI.message "What's new (#{version_localization.locale}):\n#{version_localization.whats_new}"
        UI.message '-----'
      end
    end
    UI.message '-----'

    run_publish_release_notes(new_live_version_found) if publish_release_notes
  end

  desc 'Get AppStore TestFlight App status for iOS and tvOS, lastest version'
  lane :appStoreTestFlightAppStatus do
    UI.message '-----'
    business_units.map do |business_unit|
      spaceship_login_with_api_key(business_unit)
      app = spaceship_bu_appstore_build_app(business_unit)
      next unless app

      UI.message '-----'
      UI.command_output "Switch to Play #{business_unit}"

      group_builds = spaceship_app_beta_group_builds(app)

      UI.message '-----'
      ['iOS', 'tvOS'].map do |platform|
        UI.message "Builds for Play #{business_unit} #{platform}"

        latest_version = spaceship_app_latest_known_version(platform, app)
        next unless latest_version

        version = latest_version.version_string
        builds = spaceship_app_builds(app.id, version, platform)

        builds.filter { |build| !build.expired }.each do |build|
          message = "Build Version: #{version}-#{build.version} (#{build.processing_state})"
          build.processing_state == 'VALID' ? UI.success(message) : UI.important(message)

          beta_detail = build.build_beta_detail
          if beta_detail
            beta_state = 'IN_BETA_TESTING'

            int_state = spaceship_app_internal_groups_state(beta_detail, group_builds, build.id)
            int_message = int_state[:message]
            int_state[:state] == beta_state ? UI.success(int_message) : UI.important(int_message)

            ext_state = spaceship_app_external_groups_state(beta_detail, group_builds, build.id)
            ext_message = ext_state[:message]
            ext_state[:state] == beta_state ? UI.success(ext_message) : UI.important(ext_message)

          else
            UI.important('Internal: NaN / External: NaN')
          end
        end
        UI.message '-----'
      end
    end
    UI.message '-----'
  end

  # Public Release notes

  desc 'Publish release notes for iOS and tvOS on Github pages'
  lane :publishReleaseNotes do
    output_directory = "fastlane/export/#{lane_context[SharedValues::LANE_NAME]}"

    copy_static_github_pages_files(output_directory)

    releases_directory = "#{output_directory}/releases"
    Dir.chdir('..') { FileUtils.mkdir_p(releases_directory) }

    ['iOS', 'tvOS'].map do |platform|
      UI.message "Preparing Play #{platform} beta release notes. 📝"

      json = what_s_new_for_beta_json(platform)
      divs = beta_release_notes_table_to_html_divs(json)
      html = beta_release_notes_html(platform, divs)

      release_html_file = "release_notes-#{platform.downcase}-beta.html"
      Dir.chdir('..') { File.write("#{releases_directory}/#{release_html_file}", html) }

      latest_version = json.keys.last
      UI.success "Computed Play #{platform} beta release notes (latest beta: #{latest_version}). ✅"
    end

    business_units.map do |business_unit|
      spaceship_login_with_api_key(business_unit)
      app = spaceship_bu_appstore_build_app(business_unit)

      ['iOS', 'tvOS'].map do |platform|
        UI.message "Preparing Play #{business_unit} #{platform} release notes. 📝"

        live_version = spaceship_app_live_version(platform, app)

        table = release_notes_table_for_html(platform, business_unit)
        divs = release_notes_table_to_html_divs(platform, table, live_version)
        html = release_notes_html(platform, business_unit, divs)

        release_html_file = "release_notes-#{platform.downcase}-#{business_unit.downcase}.html"
        Dir.chdir('..') { File.write("#{releases_directory}/#{release_html_file}", html) }

        upcoming_version = table[0][0]
        upcoming_version = 'NaN' if live_version.version_string == upcoming_version
        UI.success "Computed Play #{business_unit} #{platform} release notes (release: #{live_version.version_string}, upcoming: #{upcoming_version}). ✅"
      end
    end

    UI.message 'Start Play release notes publication on Github pages.'
    publish_on_github_pages(output_directory, releases_directory)
    UI.success 'Play release notes pushed on Github pages. ✅'
  end

  # After AppStore release

  desc 'After an AppStore release: Bumps marketing version and pushes if one AppStore live version is same as the current marketing version.'
  lane :afterAppStoreRelease do
    unless git_branch_name == github_main_branch
      UI.user_error! 'After AppStore release must be run on \'main\' branch.'
    end

    appstore_live_versions = { 'iOS' => [], 'tvOS' => [] }

    # Get App Store live versions
    UI.message '-----'
    business_units.map do |business_unit|
      spaceship_login_with_api_key(business_unit)
      app = spaceship_bu_appstore_build_app(business_unit)
      next unless app

      UI.message '-----'
      UI.command_output "Switch to Play #{business_unit}"

      ['iOS', 'tvOS'].map do |platform|
        live_version = spaceship_app_live_version(platform, app)
        UI.success "Play #{business_unit} #{platform} live version #{live_version.version_string} (#{live_version.build.version}) is #{live_version.app_store_state}." if live_version
        UI.important "Play #{business_unit} #{platform} has no live version." unless live_version

        appstore_live_versions[platform] << live_version.version_string if live_version
      end
    end
    UI.message '-----'

    # Bump marketing version if needed
    appstore_live_versions.each do |platform, appstore_versions|
      bump_marketing_version_flow(platform, appstore_versions)
    end
  end

  # Individual iOS screenshots

  desc 'RSI: Makes iOS screenshots and replaces current ones on App Store Connect.'
  lane :iOSrsiScreenshots do
    platform = 'iOS'

    screenshots(platform, 'RSI')
    upload_screenshots(platform)
  end

  desc 'RTR: Makes iOS screenshots. No replacement made on App Store Connect.'
  lane :iOSrtrScreenshots do
    platform = 'iOS'

    screenshots(platform, 'RTR')
    # Don't erase existing screenshots, from RTR marketing team.
  end

  desc 'RTS: Makes iOS screenshots. No replacement made on App Store Connect.'
  lane :iOSrtsScreenshots do
    platform = 'iOS'

    screenshots(platform, 'RTS')
    # Don't erase existing screenshots, from RTS marketing team.
  end

  desc 'SRF: Makes iOS screenshots. No replacement made on App Store Connect.'
  lane :iOSsrfScreenshots do
    platform = 'iOS'

    screenshots(platform, 'SRF')
    # Don't erase existing screenshots, from SRF marketing team.
  end

  # Individual iOS App Store build uploads

  desc 'RSI only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSrsiUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'RSI')
  end

  desc 'RTR only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSrtrUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'RTR')
  end

  desc 'RTS only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSrtsUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'RTS')
  end

  desc 'SRF only: See `iOSUploadAppStoreBuilds` lane.'
  lane :iOSsrfUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'iOS', bu: 'SRF')
  end

  # Individual iOS App Store build distributions

  desc 'RSI only: See `iOSDistributeAppStoreBuilds` lane.'
  lane :iOSrsiDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'iOS',
      bu: 'RSI',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  desc 'RTR only: See `iOSDistributeAppStoreBuilds` lane.'
  lane :iOSrtrDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'iOS',
      bu: 'RTR',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  desc 'RTS only: See `iOSDistributeAppStoreBuilds` lane.'
  lane :iOSrtsDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'iOS',
      bu: 'RTS',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  desc 'SRF only: See `iOSDistributeAppStoreBuilds` lane.'
  lane :iOSsrfDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'iOS',
      bu: 'SRF',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  # Individual iOS AppStore releases

  desc 'RSI only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSrsiPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'RSI', options)
  end

  desc 'RTR only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSrtrPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'RTR', options)
  end

  desc 'RTS only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSrtsPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'RTS', options)
  end

  desc 'SRF only: See `iOSPrepareAppStoreRelease` lane.'
  lane :iOSsrfPrepareAppStoreRelease do |options|
    prepare_appstore_release('iOS', 'SRF', options)
  end

  # Individual tvOS screenshots

  desc 'RSI: Makes tvOS screenshots and replaces current ones on App Store Connect.'
  lane :tvOSrsiScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'RSI')
    upload_screenshots(platform)
  end

  desc 'RTR: Makes tvOS screenshots. No replacement made on App Store Connect.'
  lane :tvOSrtrScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'RTR')
    # Don't erase existing screenshots, from RTR marketing team.
  end

  desc 'RTS: Makes tvOS screenshots. No replacement made on App Store Connect.'
  lane :tvOSrtsScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'RTS')
    # Don't erase existing screenshots, from RTS marketing team.
  end

  desc 'SRF: Makes tvOS screenshots. No replacement made on App Store Connect.'
  lane :tvOSsrfScreenshots do
    platform = 'tvOS'

    screenshots(platform, 'SRF')
    # Don't erase existing screenshots, from SRF marketing team.
  end

  # Individual tvOS App Store build uploads

  desc 'RSI only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSrsiUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'RSI')
  end

  desc 'RTR only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSrtrUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'RTR')
  end

  desc 'RTS only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSrtsUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'RTS')
  end

  desc 'SRF only: See `tvOSUploadAppStoreBuilds` lane.'
  lane :tvOSsrfUploadAppStoreBuild do
    testflight_appstore_build_upload(platform: 'tvOS', bu: 'SRF')
  end

  # Individual tvOS App Store build distributions

  desc 'RSI only: See `tvOSDistributeAppStoreBuilds` lane.'
  lane :tvOSrsiDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'tvOS',
      bu: 'RSI',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  desc 'RTR only: See `tvOSDistributeAppStoreBuilds` lane.'
  lane :tvOSrtrDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'tvOS',
      bu: 'RTR',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  desc 'RTS only: See `tvOSDistributeAppStoreBuilds` lane.'
  lane :tvOSrtsDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'tvOS',
      bu: 'RTS',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  desc 'SRF only: See `tvOSDistributeAppStoreBuilds` lane.'
  lane :tvOSsrfDistributeAppStoreBuild do |options|
    testflight_distribute_appstore_build(
      platform: 'tvOS',
      bu: 'SRF',
      tag_version: options[:tag_version],
      public_beta_distribution: options[:public_beta_distribution]
    )
  end

  # Individual tvOS AppStore releases

  desc 'RSI only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSrsiPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'RSI', options)
  end

  desc 'RTR only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSrtrPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'RTR', options)
  end

  desc 'RTS only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSrtsPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'RTS', options)
  end

  desc 'SRF only: See `tvOSPrepareAppStoreRelease` lane.'
  lane :tvOSsrfPrepareAppStoreRelease do |options|
    prepare_appstore_release('tvOS', 'SRF', options)
  end

  #
  # Private lanes
  #

  desc 'See iOSnightlies and tvOSnightlies lane descriptions.'
  private_lane :testflight_nightlies do |options|
    platform = options[:platform] || 'iOS'
    service = 'TestFlight'

    build_number = srg_latest_testflight_build_number(appstore_nightly_identifiers, platform)
    xcode_override_build_number(build_number + 1)

    tag_version = tag_version(platform)
    branch_name = git_branch_name

    # Update CI information because of build number overrided
    notify_version_to_ci(platform, tag_version, branch_name)

    schemes = application_schemes(platform)
    schemes.each_index do |index|
      app_identifier = appstore_nightly_identifiers[index]

      build_lane(
        configuration: 'Nightly',
        scheme: schemes[index],
        display_name_suffix: nightly_display_name_suffix(branch_name),
        version_suffix: version_suffix('-nightly', branch_name),
        build_name: build_name(branch_name),
        platform:,
        export_to_appstore: true
      )

      pilot_fast_upload(app_identifier, platform)

      UI.success "#{schemes[index]} (#{platform} Nightly #{tag_version}) uploaded. ✅"

      appcenter_appname = appcenter_testflight_nightly_names(platform)[index]
      upload_appcenter_dsyms(appcenter_appname)

      UI.success "#{schemes[index]} (#{platform} Nightly #{tag_version}) dSYM file OK. ✅"

      clean_build_artifacts
    end

    changelog = nightly_changelog(platform, service, branch_name)

    schemes.each_index do |index|
      app_identifier = appstore_nightly_identifiers[index]

      pilot_distribute(app_identifier, platform, tag_version, changelog, false)

      UI.success "#{schemes[index]} (#{platform} Nightly #{tag_version}) distributed. ✅"
    end

    save_last_nightlies_success_git_commit_hash(platform, service)
  end

  desc 'See iOSbetas and tvOSbetas lane descriptions.'
  private_lane :testflight_betas do |options|
    platform = options[:platform] || 'iOS'

    tag_version = tag_version(platform)
    branch_name = git_branch_name

    schemes = application_schemes(platform)
    schemes.each_index do |index|
      app_identifier = appstore_beta_identifiers[index]

      can_upload = can_upload_testflight_build(app_identifier, platform, tag_version)
      UI.message "#{schemes[index]} (#{platform} Beta #{tag_version}) already uploaded 🔁 ✅" unless can_upload
      next unless can_upload

      build_lane(
        configuration: 'Beta',
        scheme: schemes[index],
        display_name_suffix: beta_display_name_suffix(branch_name),
        version_suffix: version_suffix('-beta', branch_name),
        build_name: build_name(branch_name),
        platform:,
        export_to_appstore: true
      )

      pilot_fast_upload(app_identifier, platform)

      UI.success "#{schemes[index]} (#{platform} Beta #{tag_version}) uploaded. ✅"

      appcenter_appname = appcenter_testflight_beta_names(platform)[index]
      upload_appcenter_dsyms(appcenter_appname)

      UI.success "#{schemes[index]} (#{platform} Beta #{tag_version}) dSYM file OK. ✅"

      clean_build_artifacts
    end

    changelog = what_s_new_for_beta(platform, tag_version)

    schemes.each_index do |index|
      app_identifier = appstore_beta_identifiers[index]

      pilot_distribute(app_identifier, platform, tag_version, changelog, false)

      UI.success "#{schemes[index]} (#{platform} Beta #{tag_version}) distributed. ✅"
    end

    slack_beta_release(platform, tag_version)

    beta_workflow(platform)
  end

  desc 'Builds a new App Store build on App Store Connect with the current build number and and skips build processing.'
  private_lane :testflight_appstore_build_upload do |options|
    platform = options[:platform] || 'iOS'
    business_unit = options[:bu]
    scheme = application_scheme(platform, business_unit)

    UI.important 'A valid bu option is required to build an App Store build. Skipping build. ⚠️' unless scheme
    next unless scheme

    tag_version = tag_version(platform)
    branch_name = git_branch_name

    can_upload = can_upload_testflight_build(nil, platform, tag_version)
    UI.message "#{scheme} (#{platform} App Store #{tag_version}) already uploaded 🔁 ✅" unless can_upload
    next unless can_upload

    build_lane(
      configuration: 'AppStore',
      scheme:,
      display_name_suffix: appstore_display_name_suffix(branch_name),
      version_suffix: version_suffix('', branch_name),
      build_name: build_name(branch_name),
      platform:,
      export_to_appstore: true
    )

    pilot_fast_upload(nil, platform)

    UI.success "#{scheme} (#{platform} App Store #{tag_version}) uploaded ✅"

    appcenter_appname = appcenter_appstore_build_names(platform)[business_unit_index(business_unit)]
    upload_appcenter_dsyms(appcenter_appname)

    UI.success "#{scheme} (#{platform} App Store #{tag_version}) dSYM file OK. ✅"

    clean_build_artifacts
  end

  desc 'Distributes the App Store build on App Store Connect with the current build number to TestFlight groups.'
  private_lane :testflight_distribute_appstore_build do |options|
    platform = options[:platform] || 'iOS'
    tag_version = tag_version_from_options(options) || tag_version(platform)
    scheme = application_scheme(platform, options[:bu])
    public_beta_distribution = options[:public_beta_distribution] || true

    UI.important 'A valid bu option is required to distribute an App Store build. Skipping distribution. ⚠️' unless scheme
    next unless scheme

    changelog = what_s_new_for_beta(platform, tag_version)
    pilot_distribute(nil, platform, tag_version, changelog, public_beta_distribution)

    UI.success "#{scheme} (#{platform} App Store #{tag_version}) distributed to #{groups_string(public_beta_distribution)}. ✅"
  end

  desc 'Builds for a scheme and a configuration'
  private_lane :build_lane do |options|
    options[:export_to_appstore] ||= false
    options[:display_name_suffix] ||= ''
    options[:version_suffix] ||= ''
    options[:build_name] ||= ''
    options[:platform] ||= 'iOS'
    options[:version] = xcode_marketing_version(options[:platform])

    options = update_options_to_appstore(options)

    options[:team_id] = app_config.try_fetch_value(:team_id)

    # CI can take time to be ready to start the build
    ENV['FASTLANE_XCODEBUILD_SETTINGS_RETRIES'] = '10'

    destination = "generic/platform=#{options[:platform]}"
    lane_name = lane_context[SharedValues::LANE_NAME]
    output_directory = "fastlane/export/#{lane_name}/"
    gym(
      configuration: options[:configuration],
      scheme: options[:scheme],
      silent: true,
      xcargs: srg_xcargs(options),
      export_method: options[:export_to_appstore] ? 'app-store' : 'enterprise',
      include_bitcode: false,
      export_team_id: options[:team_id],
      destination:,
      derived_data_path:,
      output_directory:
    )
  end

  desc 'Add tester to TestFlight, by default for betas'
  private_lane :addTestFlightTester do |options|
    email = spaceship_email_required(options[:email])
    email ||= spaceship_email_required(prompt(text: 'email: '))
    return UI.user_error! 'A valid email is required. (email parameter)' unless email

    UI.message "Preparing invitations to #{email}. 📩"

    app_identifiers = options[:app_identifiers] || appstore_beta_identifiers
    group_name = options[:group_name] || ENV.fetch('ITUNES_CONNECT_TF_GROUPS', nil)

    spaceship_login

    app_identifiers.each do |app_identifier|
      app = spaceship_app(app_identifier)
      next unless app

      group = spaceship_get_group(app, group_name)
      next unless group

      tester = spaceship_get_tester(app, email)
      if tester
        if tester.status == 'invited'
          spaceship_delete_tester(app, tester)
          UI.message "#{email} was invited as a tester for #{app.name}. Invitation removed. 📨 🚮"
        else # accepted or installed
          UI.message "#{email} is already a tester for #{app.name} (status: #{tester.status}). 🔁 ✅"
          next
        end
      end

      spaceship_add_tester(group, email, options[:first_name], options[:last_name])

      UI.success "#{email} tester added to #{group.name} for #{app.name}. Invitation sent. 📨 ✅"
    end
  end

  after_all do |lane|
    update_github_deployment_success(lane)

    add_github_deployment_tag_success(lane)

    if cleaned_lane_condition(lane)
      ENV.delete('DERIVED_DATA_CLEANED')
      reset_git_repo(skip_clean: true)
    end
  end

  error do |lane|
    UI.important 'An action has triggered an error. End of lane execution. ⚠️'

    update_github_deployment_error(lane)

    if cleaned_lane_condition(lane)
      clean_build_artifacts
      ENV.delete('DERIVED_DATA_CLEANED')
      reset_git_repo(force: true)
    end
  end
end

#
# Constants
#

APP_STORE_STATE = Spaceship::ConnectAPI::AppInfo::AppStoreState

#
# Functions
#

def business_units
  ['RTS', 'SRF', 'RSI', 'RTR']
end

def business_unit_index(business_unit)
  business_units.index(business_unit.upcase)
end

def ios_application_schemes
  business_units.map { |business_unit| "Play #{business_unit}" }
end

def tvos_application_schemes
  business_units.map { |business_unit| "Play #{business_unit} TV" }
end

def srg_platforms
  ['iOS', 'tvOS']
end

def application_schemes(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    ios_application_schemes
  else
    tvos_application_schemes
  end
end

def application_scheme(platform, business_unit)
  platform ||= 'iOS'

  application_schemes(platform)[business_unit_index(business_unit)]
end

def screenshots_scheme(platform, business_unit)
  platform ||= 'iOS'

  application_scheme = application_scheme(platform, business_unit)
  return unless application_scheme

  "#{application_scheme} screenshots"
end

def app_config
  CredentialsManager::AppfileConfig
end

def platform(lane)
  lane.to_s.downcase.include?('tvos') ? 'tvOS' : 'iOS'
end

def tag_condition(lane)
  included_lanes = ['appstorebuild', 'beta']
  included_lanes.one? { |i| lane.to_s.downcase.include? i }
end

def what_s_new_condition(lane)
  included_lanes = ['appstorebuild', 'beta']
  (!lane.to_s.downcase.include? 'tester') &&
    included_lanes.one? { |i| lane.to_s.downcase.include? i }
end

def cleaned_lane_condition(lane)
  excluded_lanes = [
    'distribute',
    'screenshots',
    'appstorerelease',
    'status',
    'tester',
    'githubdeployments'
  ]
  (lane.to_s != 'devLane') &&
    excluded_lanes.all? { |i| !lane.to_s.downcase.include? i }
end

def skip_clean_derived_data
  ENV['DERIVED_DATA_CLEANED'] == '1'
end

def clean_derived_data
  Dir.chdir('..') { FileUtils.remove_entry(derived_data_path, true) }
  ENV['DERIVED_DATA_CLEANED'] = '1'
end

def derived_data_path
  'build/DerivedData'
end

def notify_ci_condition(lane)
  !lane.to_s.downcase.include?('githubdeployments')
end

def appcenter_dsyms_upload(app_name, release_notes, dsym)
  appcenter_upload(
    api_token: ENV.fetch('PLAY_APPCENTER_TOKEN', nil),
    owner_type: 'organization',
    owner_name: ENV.fetch('PLAY_APPCENTER_OWNER', nil),
    app_name:,
    release_notes:,
    upload_dsym_only: true,
    dsym:
  )
end

def appcenter_tvos_nightly_names
  business_units.map do |business_unit|
    ENV.fetch("PLAY_#{business_unit}_TV_NIGHTLY_APPCENTER_APPNAME", nil)
  end
end

def appcenter_ios_nightly_names
  business_units.map do |business_unit|
    ENV.fetch("PLAY_#{business_unit}_IOS_NIGHTLY_APPCENTER_APPNAME", nil)
  end
end

def appcenter_testflight_nightly_names(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    appcenter_ios_nightly_names
  else
    appcenter_tvos_nightly_names
  end
end

def appcenter_tvos_beta_names
  business_units.map do |business_unit|
    ENV.fetch("PLAY_#{business_unit}_TV_BETA_APPCENTER_APPNAME", nil)
  end
end

def appcenter_ios_beta_names
  business_units.map do |business_unit|
    ENV.fetch("PLAY_#{business_unit}_IOS_BETA_APPCENTER_APPNAME", nil)
  end
end

def appcenter_testflight_beta_names(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    appcenter_ios_beta_names
  else
    appcenter_tvos_beta_names
  end
end

def appcenter_tvos_appstore_build_names
  business_units.map do |business_unit|
    ENV.fetch("PLAY_#{business_unit}_TV_APPSTORE_APPCENTER_APPNAME", nil)
  end
end

def appcenter_ios_appstore_build_names
  business_units.map do |business_unit|
    ENV.fetch("PLAY_#{business_unit}_APPSTORE_APPCENTER_APPNAME", nil)
  end
end

def appcenter_appstore_build_names(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    appcenter_ios_appstore_build_names
  else
    appcenter_tvos_appstore_build_names
  end
end

def appstore_nightly_identifiers
  business_units.map do |business_unit|
    ENV.fetch("ITUNES_CONNECT_NIGHLTY_#{business_unit}_APP_IDENTIFIER", nil)
  end
end

def appstore_beta_identifiers
  business_units.map do |business_unit|
    ENV.fetch("ITUNES_CONNECT_BETA_#{business_unit}_APP_IDENTIFIER", nil)
  end
end

def appstore_build_identifiers
  business_units.map { |business_unit| ENV.fetch("#{business_unit}_APP_IDENTIFIER", nil) }
end

def itc_business_units
  # RTR is in SRG SSR ASC team
  business_units.map do |business_unit|
    business_unit == 'RTR' ? 'SRGSSR' : business_unit
  end
end

def itc_team_ids
  itc_business_units.map do |itc_business_unit|
    ENV.fetch("#{itc_business_unit}_ITUNES_CONNECT_TEAM_ID", nil)
  end
end

def itc_team_id_index(itc_team_id)
  itc_team_ids.index(itc_team_id)
end

def tag_version_from_options(options)
  # CI can set an empty string
  tag_version = options[:tag_version] || ''
  tag_version unless tag_version.empty?
end

# Returns current tag version
def tag_version(platform)
  "#{xcode_marketing_version(platform)}-#{xcode_build_number}"
end

def srg_tag(platform)
  srg_tag_from_tag_version(platform, tag_version(platform))
end

def srg_tag_from_tag_version(platform, tag_version)
  "#{platform.downcase}/#{tag_version}"
end

def srg_tag_from_spaceship_app_version(platform, spaceship_app_version)
  tag_version = "#{spaceship_app_version.version_string}-#{spaceship_app_version.build.version}"
  srg_tag_from_tag_version(platform, tag_version)
end

def platform_from_tag(tag)
  tag.split('/').first
end

def tag_version_from_tag(tag)
  tag.split('/').last
end

def build_number_from_tag_version(tag_version)
  tag_version.split('-').last
end

def marketing_version_from_tag_version(tag_version)
  tag_version.split('-').first
end

# Returns the what's new text from WhatsNew-[platform]-beta.json file in the repository
def what_s_new_for_beta(platform, tag_version)
  tag_version ||= tag_version(platform)

  json = what_s_new_for_beta_json(platform)
  what_s_new = json[tag_version] || ''
  if !what_s_new.empty? &&
     !build_name(git_branch_name).empty? && !what_s_new.downcase.include?('branch')
    what_s_new = "This build is from a test branch.\n\n#{what_s_new}"
  end
  what_s_new
end

def build_number_for_version(platform, version)
  json = what_s_new_for_beta_json(platform)
  tag_version = json.keys.select { |key| marketing_version_from_tag_version(key) == version }.last
  tag_version ? build_number_from_tag_version(tag_version) : '999999'
end

def what_s_new_for_beta_json(platform)
  file = File.open("../#{what_s_new_beta_file_name(platform)}", 'r')
  json = JSON.parse(file.read)
  file.close
  json
end

def what_s_new_beta_file_name(platform)
  "WhatsNew-#{platform}-beta.json"
end

def what_s_new_beta_commits_check_count
  3
end

def what_s_new_beta_commits(platform)
  commits = []

  beta_file_name = what_s_new_beta_file_name(platform)
  git_last_commit_hashes(what_s_new_beta_commits_check_count).each do |commit_hash|
    files = git_commited_files(commit_hash)
    is_what_s_new = files.one? { |file| file.include? beta_file_name }
    commits.append(commit_hash) if is_what_s_new
  end

  commits
end

def release_notes_html_devices(platform)
  platform == 'iOS' ? 'iPhone & iPad' : 'Apple TV'
end

def release_notes_html(platform, business_unit, divs)
  release_notes_html_export(business_unit.downcase, platform, divs)
end

def beta_release_notes_html(platform, divs)
  release_notes_html_export('beta', platform, divs)
end

def release_notes_html_export(file_suffix, platform, divs)
  input_file = "release_notes-#{file_suffix}.html"
  html = File.read("gh-pages/releases/#{input_file}")
  html = html.gsub('<!-- platform -->', platform)
  html = html.gsub('<!-- devices -->', release_notes_html_devices(platform))
  html.sub('<!-- versions -->', divs.strip)
end

def release_notes_table_to_html_divs(platform, table, live_version)
  divs = ''
  table.map do |row|
    is_preprod = version_is_preprod(platform, row[0], live_version)
    divs += release_notes_version_to_html(platform, row[0], row[1], is_preprod)
  end
  divs.strip
end

def beta_release_notes_table_to_html_divs(json)
  divs = ''
  json.keys.reverse.map do |key|
    divs += beta_release_notes_version_to_html(key, json[key])
  end
  divs.strip
end

def release_notes_version_to_html(platform, version, text, is_preprod)
  build_number = build_number_for_version(platform, version)
  release_notes_version_to_html_export(build_number, version, text, is_preprod)
end

def beta_release_notes_version_to_html(tag_version, text)
  build_number = build_number_from_tag_version(tag_version)
  version = "#{marketing_version_from_tag_version(tag_version)} (#{build_number})"
  release_notes_version_to_html_export(build_number, version, text, false)
end

def release_notes_version_to_html_export(build_number, version, text, is_preprod)
  attribute = is_preprod ? ' preprod' : ''
  div = "<div id=\"build_#{build_number}\"#{attribute}>\n<h2 id=\"#{version}\">#{version}</h2>\n"
  div += release_notes_to_html(text)
  div += "\n</div>\n"
  div
end

def version_is_preprod(platform, version, live_version)
  released_version = live_version.version_string
  released_build = live_version.build.version
  build_number = build_number_for_version(platform, version)

  version != released_version && build_number > released_build
end

def release_notes_to_html(text)
  output = ''
  in_list = false
  text.each_line.reject { |line| line.strip == '' }.map do |line|
    if line.start_with?('-')
      output += "<ul>\n" unless in_list
      in_list = true
      output += "<li>#{line[1..].strip}</li>\n"
    else
      output += "</ul>\n" if in_list
      in_list = false
      output += "<p>#{line.strip}</p>\n"
    end
  end
  output += '</ul>' if in_list
  output.strip
end

# Characters "-" or "+" in version are not allowed on App Store Connect.
def update_options_to_appstore(options)
  return options unless options[:export_to_appstore]

  options[:version_suffix] = ''
  version = options[:version]
  index = version.index('-')
  return options unless index

  options[:version] = version[0..index - 1]
  options
end

def srg_xcargs(options)
  xcargs = 'ENABLE_BITCODE=NO'
  xcargs += " BUNDLE_DISPLAY_NAME_SUFFIX='#{options[:display_name_suffix]}'"
  xcargs += " MARKETING_VERSION='#{options[:version]}'"
  xcargs += " MARKETING_VERSION_SUFFIX='#{options[:version_suffix]}'"
  xcargs += " BUILD_NAME='#{options[:build_name]}'"
  xcargs += " DEVELOPMENT_TEAM='#{options[:team_id]}'"
  xcargs + srg_xcargs_code_signing(options)
end

# Use cloud signing if available
def srg_xcargs_code_signing(options)
  export_to_appstore = options[:export_to_appstore] || false
  asc_api_key = srg_app_store_connect_api_key if export_to_appstore

  xcargs = ''
  if asc_api_key
    xcargs += " -authenticationKeyIssuerID '#{asc_api_key[:issuerId]}'"
    xcargs += " -authenticationKeyID '#{asc_api_key[:id]}'"
    xcargs += " -authenticationKeyPath '#{asc_api_key[:filePath]}'"
  end
  "#{xcargs} -allowProvisioningUpdates"
end

def nightly_display_name_suffix(branch_name)
  nightly_display_name_suffix = ' 🌙'
  nightly_display_name_suffix = ' 🌱' unless branch_name == github_main_branch
  nightly_display_name_suffix
end

def beta_display_name_suffix(branch_name)
  beta_display_name_suffix = ' 🎯'
  beta_display_name_suffix = ' 🪴' unless branch_name == github_main_branch
  beta_display_name_suffix
end

def appstore_display_name_suffix(branch_name)
  appstore_display_name_suffix = ''
  appstore_display_name_suffix = ' 🌳' unless branch_name == github_main_branch
  appstore_display_name_suffix
end

def version_suffix(version_suffix, branch_name)
  build_name = build_name(branch_name)
  return version_suffix if build_name.empty?

  "#{version_suffix}+#{build_name}"
end

def build_name(branch_name)
  if branch_name == github_main_branch
    ''
  elsif branch_name.include? 'feature/'
    branch_name.sub('feature/', '').strip
  elsif branch_name.include? 'release/'
    branch_name.sub('release/', '').strip
  elsif branch_name.include? 'hotfix/'
    branch_name.sub('hotfix/', '').strip
  elsif branch_name.include? 'fix/'
    branch_name.sub('fix/', '').strip
  else
    branch_name.strip
  end
end

# Return a nightly changelog from git commit messages
def nightly_changelog(platform, service, branch_name)
  last_commit_hash = last_nightlies_success_git_commit_hash(platform, service)
  last_commit_hash = 'HEAD^^^^^' if last_commit_hash.length < 12

  changelog = changelog_from_git_commits(
    between: [last_commit_hash, 'HEAD'],
    pretty: '- %s'
  )

  # HAX: strip emoji from changelog
  changelog = changelog ? changelog.sub(/[\u{1F300}-\u{1F6FF}]/, '').lstrip : ''

  changelog = 'No change log found for this build.' unless changelog && !changelog.empty?

  "Built from #{branch_name} branch\n\n#{changelog}"
end

# Save the git commit hash in a local text file for nightlies
def save_last_nightlies_success_git_commit_hash(platform, service)
  last = last_git_commit
  platform = platform ? "#{platform.downcase}-" : ''
  service = service ? "#{service.downcase}-" : ''
  file_name = "last-#{service}#{platform}nightlies-success-git-commit-hash.txt"
  File.write(file_name, last[:commit_hash])
  last[:commit_hash]
end

# Read the git commit hash in a local text file for nightlies
def last_nightlies_success_git_commit_hash(platform, service)
  platform = platform ? "#{platform.downcase}-" : ''
  service = service ? "#{service.downcase}-" : ''
  file_name = "last-#{service}#{platform}nightlies-success-git-commit-hash.txt"
  file = File.open(file_name, 'a+')
  nightlies_success_git_commit_hash = file.read
  file.close
  nightlies_success_git_commit_hash
end

# Returns the marketing version for a platform, without suffix
def xcode_marketing_version(platform)
  get_xcconfig_value(
    path: srg_xcconfig_path(platform),
    name: 'MARKETING_VERSION'
  )
end

# Override marketing version for a platform (current project version)
def xcode_override_marketing_version(platform, marketing_version)
  update_xcconfig_value(
    path: srg_xcconfig_path(platform),
    name: 'MARKETING_VERSION',
    value: marketing_version
  )
  marketing_version
end

# Returns the build number
def xcode_build_number
  get_xcconfig_value(
    path: srg_xcconfig_common_path,
    name: 'CURRENT_PROJECT_VERSION'
  )
end

# Override build number (current project version)
def xcode_override_build_number(build_number)
  update_xcconfig_value(
    path: srg_xcconfig_common_path,
    name: 'CURRENT_PROJECT_VERSION',
    value: build_number.to_s
  )
  build_number.to_s
end

def srg_xcconfig_path(platform)
  "Xcode/Shared/Targets/#{platform}/Common.xcconfig"
end

def srg_xcconfig_common_path
  'Xcode/Shared/Common.xcconfig'
end

def appstore_platform(platform)
  appstore_platforms = { 'iOS' => 'ios', 'tvOS' => 'appletvos' }
  appstore_platforms[platform]
end

def srg_app_store_connect_api_key(business_unit = nil)
  business_unit ||= business_units[itc_team_id_index(app_config.try_fetch_value(:itc_team_id))]
  key_prefix = itc_business_units[business_unit_index(business_unit)]
  return unless key_prefix

  folder_path = Dir.chdir('..') { Dir.pwd }
  { id: ENV.fetch("#{key_prefix}_APPSTORE_CONNECT_API_KEY_ID", nil),
    issuerId: ENV.fetch("#{key_prefix}_APPSTORE_CONNECT_API_KEY_ISSUER_ID", nil),
    filePath: "#{folder_path}/Configuration/#{ENV.fetch(
      "#{key_prefix}_APPSTORE_CONNECT_API_KEY_PATH", nil
    )}" }
end

def login_with_app_store_connect_api_key
  asc_api_key = srg_app_store_connect_api_key
  return unless asc_api_key

  app_store_connect_api_key(
    key_id: asc_api_key[:id],
    issuer_id: asc_api_key[:issuerId],
    key_filepath: asc_api_key[:filePath]
  )
end

def pilot_fast_upload(app_identifier, platform)
  app_identifier ||= app_config.try_fetch_value(:app_identifier)
  platform ||= 'iOS'

  lane_context.delete(SharedValues::FL_CHANGELOG)

  login_with_app_store_connect_api_key
  pilot(
    app_identifier:,
    app_platform: appstore_platform(platform),
    skip_waiting_for_build_processing: true
  )
end

def pilot_distribute(app_identifier, platform, tag_version, changelog, public_beta_distribution)
  app_identifier ||= app_config.try_fetch_value(:app_identifier)
  platform ||= 'iOS'
  tag_version ||= tag_version(platform)
  public_beta_distribution ||= true

  srg_pilot_distribute(app_identifier, platform, tag_version, changelog, public_beta_distribution)
rescue StandardError => e
  raise unless e.message.include? 'Another build is in review'

  UI.important 'Another build is already in TestFlight app review. Skipping external distribution. ⚠️'
end

def srg_pilot_distribute(app_identifier, platform, tag_version, changelog, public_beta_distribution)
  login_with_app_store_connect_api_key
  pilot(
    distribute_only: true,
    app_identifier:,
    app_platform: appstore_platform(platform),
    app_version: marketing_version_from_tag_version(tag_version),
    build_number: build_number_from_tag_version(tag_version),
    changelog:,
    distribute_external: true,
    groups: testflight_groups(public_beta_distribution),
    notify_external_testers: true,
    demo_account_required: false,
    beta_app_review_info:
  )
end

def testflight_groups(public_beta_distribution)
  groups = ENV.fetch('ITUNES_CONNECT_TF_GROUPS', nil)
  groups += ",#{ENV.fetch('ITUNES_CONNECT_TF_PUBLIC_GROUPS', nil)}" if public_beta_distribution
  groups
end

def groups_string(public_beta_distribution)
  public_beta_distribution ? 'public and private groups' : 'private group'
end

def upload_appcenter_dsyms(appcenter_appname)
  dsym = lane_context[SharedValues::DSYM_OUTPUT_PATH]
  begin
    appcenter_dsyms_upload(
      appcenter_appname,
      'DSYMs from local build (via fastlane).',
      dsym
    )
  rescue StandardError => e
    UI.important "Error uploading dSYM to App Center: #{e.message}"
    Dir.chdir('..') { FileUtils.cp(dsym, 'build') }
    UI.message "#{dsym.split('/').last} file copied to ./build folder."
  end
  lane_context.delete(SharedValues::DSYM_OUTPUT_PATH)
end

# Returns current build number on App Store Connect
def srg_latest_testflight_build_number(app_identifiers, platform)
  login_with_app_store_connect_api_key

  build_number = 0
  app_identifiers.each_index do |index|
    number = latest_testflight_build_number(
      platform: appstore_platform(platform),
      app_identifier: app_identifiers[index]
    )

    build_number = number unless build_number >= number
  end
  build_number
end

# Share build version and number to the continuous integration
def notify_version_to_ci(platform, tag_version, branch_name)
  return unless ENV['TEAMCITY_VERSION']

  platform ||= iOS
  tag_version ||= tag_version(platform)

  displayed_build_number = build_friendly_name(tag_version, branch_name)
  puts "##teamcity[buildNumber '#{displayed_build_number}']"
end

def build_friendly_name(tag_version, branch_name)
  build_name = build_name(branch_name)
  return tag_version if build_name.empty?

  "#{tag_version}+#{build_name}"
end

def build_log_url
  ENV.fetch('BUILD_URL', nil)
end

def github_api_path
  '/repos/SRGSSR/playsrg-apple'
end

def github_main_branch
  'main'
end

def github_environment_data(lane, business_unit = nil)
  environment_datas = {
    'iOSnightlies' => { platform: 'iOS', configuration: 'Nightly', business_unit: },
    'tvOSnightlies' => { platform: 'tvOS', configuration: 'Nightly', business_unit: },
    'iOSbetas' => { platform: 'iOS', configuration: 'Beta', business_unit: },
    'tvOSbetas' => { platform: 'tvOS', configuration: 'Beta', business_unit: },
    'iOSAppStoreBuilds' => { platform: 'iOS', configuration: 'TestFlight', business_unit: },
    'tvOSAppStoreBuilds' => { platform: 'tvOS', configuration: 'TestFlight', business_unit: },
    'iOSAppStoreReleases' => { platform: 'iOS', configuration: 'AppStore' },
    'tvOSAppStoreReleases' => { platform: 'tvOS', configuration: 'AppStore', business_unit: }
  }
  environment_datas[lane.to_s]
end

def github_environment(lane, business_unit = nil)
  environment_data = github_environment_data(lane, business_unit)
  return unless environment_data

  environment = github_environments(environment_data[:platform], environment_data[:configuration])
  return unless environment

  environment += "-#{business_unit.downcase}" if business_unit
  return environment if business_unit

  build_name = build_name(git_branch_name)
  environment += "+#{build_name}" unless build_name.empty?
  environment
end

def github_environments(platform, build_configuration)
  environments = {
    'iOS' => {
      'Nightly' => 'playsrg-ios-nightly',
      'Beta' => 'playsrg-ios-beta',
      'TestFlight' => 'playsrg-ios-testflight',
      'AppStore' => 'playsrg-ios-appstore'
    },
    'tvOS' => {
      'Nightly' => 'playsrg-tvos-nightly',
      'Beta' => 'playsrg-tvos-beta',
      'TestFlight' => 'playsrg-tvos-testflight',
      'AppStore' => 'playsrg-tvos-appstore'
    }
  }
  environments[platform][build_configuration]
end

def create_or_update_github_environment(lane, business_unit = nil)
  environment = github_environment(lane, business_unit)
  return unless ENV.fetch('GITHUB_TOKEN', nil) && environment

  result = srg_github_create_or_update_environment(environment)
  name = result[:json]['name']
  return unless name

  UI.command_output "Github environment: #{name}"
end

def srg_github_create_or_update_environment(environment)
  github_api(
    api_token: ENV.fetch('GITHUB_TOKEN', nil),
    http_method: 'PUT',
    path: "#{github_api_path}/environments/#{environment}",
    error_handlers: {
      '*' => proc do |result|
        UI.important 'Something went wrong with Github token and environments API creation. ⚠️'
        UI.important result.to_s
      end
    }
  )
end

def get_github_deployments(lane, business_unit = nil)
  environment = github_environment(lane, business_unit)
  return unless ENV.fetch('GITHUB_TOKEN', nil) && environment

  max = 10
  result = srg_github_get_deployments(environment, max)
  deployments = result[:json]
  return unless deployments.is_a?(Array)

  UI.message "#{deployments.count}/#{max} Github deployments found for #{environment}"
  deployments
end

def srg_github_get_deployments(environment, max)
  encoded_environment = environment.gsub('+', '%2B')
  github_api(
    api_token: ENV.fetch('GITHUB_TOKEN', nil),
    http_method: 'GET',
    path: "#{github_api_path}/deployments?environment=#{encoded_environment}&per_page=#{max}",
    error_handlers: {
      '*' => proc do |result|
        UI.important 'Something went wrong with Github token and deployments API get. ⚠️'
        UI.important result.to_s
      end
    }
  )
end

def get_github_tag_deployment(tag, lane, business_unit = nil)
  return unless tag && !tag.empty?

  deployments = get_github_deployments(lane, business_unit)
  return unless deployments

  deployments.find { |deployment| deployment['ref'] == tag }
end

def create_github_deployment(lane)
  ENV.delete('GITHUB_DEPLOYMENT_ID')
  environment = github_environment(lane)
  return unless ENV.fetch('GITHUB_TOKEN', nil) && environment

  git_tag = github_deployment_ref_tag(lane)

  # Create only one time a tag deployment for Beta and TestFlight builds.
  # Use it if not finished successfully. Otherwise, Don't create a new deployment.
  # This can happen if the lane is re-run to update TestFlight distribution.
  tag_deployment = get_github_tag_deployment(git_tag, lane)
  return return_github_tag_deployment(tag_deployment) if tag_deployment && tag_condition(lane)

  # Try to create a deployment with the tag or the branch name.
  result = create_github_deployment_tag_or_branch(environment, git_tag)
  return unless result

  # Check the commit sha is the same as the last commit.
  return result if github_deployment_sha_correct(result)

  delete_github_deployment(lane)
  # Try to create a deployment with the last commit instead.
  create_github_deployment_ref(environment, last_git_commit[:commit_hash])
end

def return_github_tag_deployment(tag_deployment)
  return if github_tag_deployment_is_success(tag_deployment)

  ENV['GITHUB_DEPLOYMENT_ID'] = tag_deployment['id'].to_s
  UI.command_output "Github deployment: #{tag_deployment['id']}"
  tag_deployment
end

def create_github_deployment_tag_or_branch(environment, git_tag)
  if git_tag && !git_tag.empty?
    # Try to create a deployment with the tag.
    create_github_deployment_ref(environment, git_tag)
  else
    # Try to create a deployment with the branch name.
    create_github_deployment_ref(environment, git_branch_name)
  end
end

def create_github_deployment_ref(environment, ref, production_environment = nil)
  result = srg_github_create_deployment(environment, ref, production_environment)
  deployment_id = result[:json]['id']
  return unless deployment_id

  ENV['GITHUB_DEPLOYMENT_ID'] = deployment_id.to_s
  UI.command_output "Github created deployment: #{deployment_id}"
  result
end

def srg_github_create_deployment(environment, ref, production_environment = nil)
  UI.command "Github deployment creation with ref: #{ref}"
  github_api(
    api_token: ENV.fetch('GITHUB_TOKEN', nil),
    http_method: 'POST',
    path: "#{github_api_path}/deployments",
    body: srg_github_create_deployment_body(environment, ref, production_environment),
    error_handlers: {
      '*' => proc do |result|
        UI.important 'Something went wrong with Github token and deployments API creation. ⚠️'
        UI.important result.to_s
      end
    }
  )
end

def srg_github_create_deployment_body(environment, ref, production_environment = nil)
  production_environment ||= false
  task = production_environment ? 'Distribute' : 'Build and distribute'
  {
    ref:,
    auto_merge: false,
    required_contexts: [],
    environment:,
    production_environment:,
    task:,
    description: "#{task} for #{environment} environment."
  }
end

def github_deployment_sha_correct(result)
  # Tag commit can be different from the last commit.
  return true if ENV.fetch('OVERRIDE_PLAY_TAG', nil)

  last_git_commit[:commit_hash] == result[:json]['sha']
end

def github_deployment_ref_tag(lane)
  git_pull(only_tags: true)

  new_tag = ENV.fetch('OVERRIDE_PLAY_TAG', nil)
  return new_tag if new_tag && !new_tag.empty?

  tag = last_git_tag(pattern: "#{platform(lane).downcase}/*")
  tag_commit = sh("git rev-list -n 1 tags/#{tag}").strip
  return unless tag_commit && !tag_commit.empty?

  return unless last_git_commit[:commit_hash] == tag_commit

  tag
end

def github_tag_deployment_is_success(tag_deployment)
  last_status = get_github_deployment_last_status(tag_deployment)
  return false unless last_status

  is_success = last_status['state'] == 'success'
  UI.message "Github deployment state for tag #{tag_deployment['ref']} is already in success. ✅" if is_success
  is_success
end

def delete_github_deployment(lane)
  deployment_id = ENV.fetch('GITHUB_DEPLOYMENT_ID', nil)
  environment = github_environment(lane)
  return unless ENV.fetch('GITHUB_TOKEN', nil) && environment && deployment_id

  result = srg_github_delete_deployment(deployment_id)
  status = result[:status]
  return unless status == 204

  ENV.delete('GITHUB_DEPLOYMENT_ID')
  UI.command_output "Github deleted deployment: #{deployment_id}"
end

def srg_github_delete_deployment(deployment_id)
  github_api(
    api_token: ENV.fetch('GITHUB_TOKEN', nil),
    http_method: 'DELETE',
    path: "#{github_api_path}/deployments/#{deployment_id}",
    error_handlers: {
      '*' => proc do |result|
        UI.important 'Something went wrong with Github token and deployments API deletion. ⚠️'
        UI.important result.to_s
      end
    }
  )
end

# Beta workflow creates a new tag. Try to add a Github deployment with tag ref.
def add_github_deployment_tag_success(lane)
  return unless ENV.fetch('OVERRIDE_PLAY_TAG', nil)

  # Avoid having twice deployments.
  update_github_deployment_inactive(lane)
  delete_github_deployment(lane)

  create_github_deployment(lane)
  update_github_deployment_success(lane)
  ENV.delete('OVERRIDE_PLAY_TAG')
end

def appstore_github_deployment(business_unit, platform, app_version)
  return unless ENV.fetch('GITHUB_TOKEN', nil) && business_unit && platform && app_version&.build

  lane_name = "#{platform}AppStoreReleases"
  tag = srg_tag_from_spaceship_app_version(platform, app_version)

  tag_deployment = get_github_appstore_tag_deployment(tag, lane_name, business_unit)
  return unless tag_deployment

  check_appstore_github_deployment(lane_name, business_unit, app_version, tag_deployment)
end

def check_appstore_github_deployment(lane_name, business_unit, app_version, tag_deployment)
  last_status = get_github_deployment_last_status(tag_deployment)
  is_correct = github_appstore_deployment_state_is_correct(last_status, app_version)
  UI.message "Github deployment state for tag #{tag_deployment['ref']} is already synchronized. ✅" if is_correct
  return if is_correct

  state = github_deployment_state_from_app_version(app_version)
  update_github_appstore_deployment(lane_name, business_unit, tag_deployment, state)
  state
end

def get_github_appstore_tag_deployment(tag, lane_name, business_unit)
  create_or_update_github_environment(lane_name, business_unit)

  tag_deployment = get_github_tag_deployment(tag, lane_name, business_unit)
  UI.command_output "Github deployment: #{tag_deployment['id']}" if tag_deployment
  return tag_deployment if tag_deployment

  environment = github_environment(lane_name, business_unit)
  result = create_github_deployment_ref(environment, tag, true)

  result ? result[:json] : nil
end

def github_appstore_deployment_state_is_correct(last_status, app_version)
  return false unless last_status

  last_status['state'] == github_deployment_state_from_app_version(app_version)
end

def update_github_appstore_deployment(lane, business_unit, deployment, state)
  ENV['GITHUB_DEPLOYMENT_ID'] = deployment['id'].to_s
  ENV['OVERRIDE_PLAY_TAG'] = deployment['ref']

  UI.message "Github deployment state for tag #{deployment['ref']} needs synchronization. 🔄"
  update_github_deployment(state, lane, business_unit)

  ENV.delete('GITHUB_DEPLOYMENT_ID')
  ENV.delete('OVERRIDE_PLAY_TAG')
end

def github_deployment_state_from_app_version(app_version)
  case app_version.app_store_state
  when APP_STORE_STATE::WAITING_FOR_REVIEW,
       APP_STORE_STATE::READY_FOR_REVIEW then 'queued'
  when APP_STORE_STATE::IN_REVIEW then 'in_progress'
  when APP_STORE_STATE::PENDING_DEVELOPER_RELEASE,
       APP_STORE_STATE::PENDING_APPLE_RELEASE then 'pending'
  when APP_STORE_STATE::READY_FOR_SALE then 'success'
  when APP_STORE_STATE::PREPARE_FOR_SUBMISSION,
       APP_STORE_STATE::REMOVED_FROM_SALE,
       APP_STORE_STATE::DEVELOPER_REMOVED_FROM_SALE then 'inactive'
  else
    'error'
  end
end

def stop_unfinished_github_deployments(lane, business_unit = nil)
  deployments = get_github_deployments(lane, business_unit)

  return unless deployments

  deployments.reverse.each do |deployment|
    lane_name = lane.to_s
    UI.message "Checking Github deployment #{deployment['id']} for #{lane_name}"
    last_status = get_github_deployment_last_status(deployment)
    next unless github_deployment_is_unfinished(last_status)

    last_state = last_status ? last_status['state'] : 'NaN'
    UI.important "Github deployment #{deployment['id']} for #{lane_name} is unfinished with state: #{last_state}"
    stop_unfinished_github_deployment(lane, deployment, last_status)
  end
end

def stop_unfinished_github_deployment(lane, deployment, last_status)
  ENV['GITHUB_DEPLOYMENT_ID'] = deployment['id'].to_s
  original_build_url = ENV.fetch('BUILD_URL', nil)
  ENV['BUILD_URL'] = last_status['log_url']

  update_github_deployment_error(lane)

  ENV.delete('GITHUB_DEPLOYMENT_ID')
  ENV['BUILD_URL'] = original_build_url
end

def github_deployment_is_unfinished(status)
  status.nil? || !['success', 'inactive', 'error'].include?(status['state'])
end

def get_github_deployment_statuses(deployment_id)
  result = srg_github_get_deployment_statuses(deployment_id)
  statuses = result[:json]
  return unless statuses.is_a?(Array)

  statuses
end

def srg_github_get_deployment_statuses(deployment_id)
  github_api(
    api_token: ENV.fetch('GITHUB_TOKEN', nil),
    http_method: 'GET',
    path: "#{github_api_path}/deployments/#{deployment_id}/statuses",
    error_handlers: {
      '*' => proc do |result|
        UI.important 'Something went wrong with Github token and deployments API statuses get. ⚠️'
        UI.important result.to_s
      end
    }
  )
end

def get_github_deployment_last_status(deployment)
  return unless deployment

  statuses = get_github_deployment_statuses(deployment['id'])
  statuses&.first
end

def update_github_deployment_in_progress(lane)
  update_github_deployment('in_progress', lane)
end

def update_github_deployment_success(lane)
  update_github_deployment('success', lane)
end

def update_github_deployment_error(lane)
  update_github_deployment('error', lane)
end

def update_github_deployment_inactive(lane)
  update_github_deployment('inactive', lane)
end

def update_github_deployment(state, lane, business_unit = nil)
  deployment_id = ENV.fetch('GITHUB_DEPLOYMENT_ID', nil)
  environment = github_environment(lane, business_unit)
  return unless ENV.fetch('GITHUB_TOKEN', nil) && environment && deployment_id

  result = srg_github_update_deployment(environment, deployment_id, state, lane)
  deployment_state = result[:json]['state']
  return unless deployment_state

  UI.command_output "Github updated deployment state: #{deployment_state}"
end

def srg_github_update_deployment(environment, deployment_id, state, lane)
  github_api(
    api_token: ENV.fetch('GITHUB_TOKEN', nil),
    http_method: 'POST',
    path: "#{github_api_path}/deployments/#{deployment_id}/statuses",
    body: srg_github_update_deployment_body(environment, state, lane),
    error_handlers: {
      '*' => proc do |result|
        UI.important 'Something went wrong with Github token and deployments API state update. ⚠️'
        UI.important result.to_s
      end
    }
  )
end

def srg_github_update_deployment_body(environment, state, lane)
  {
    state:,
    environment:,
    description: "Building #{environment}: #{state}",
    log_url: build_log_url,
    environment_url: environment_url(state, lane),
    auto_inactive: true
  }
end

def environment_url(state, lane)
  environment_data = github_environment_data(lane)
  return unless state == 'success' && environment_data

  # Use override tag if available.
  new_tag = ENV.fetch('OVERRIDE_PLAY_TAG', nil)

  platform = platform_from_tag(new_tag) if new_tag
  platform ||= environment_data[:platform]

  version = tag_version_from_tag(new_tag) if new_tag
  version ||= build_friendly_name(tag_version(environment_data[:platform]), git_branch_name)

  'https://srgssr.github.io/playsrg-apple/deployments/build.html' \
    "?configuration=#{environment_data[:configuration]}" \
    "&platform=#{platform}" \
    "&version=#{version}"
end

# Create screenshots for App Store Connect.
def screenshots(platform, business_unit)
  platform ||= 'iOS'
  output_directory = "fastlane/export/#{lane_context[SharedValues::LANE_NAME]}"
  Dir.chdir('..') { FileUtils.mkdir_p(output_directory) }

  snapshot(
    scheme: screenshots_scheme(platform, business_unit),
    languages: [device_language(business_unit)],
    devices: snapshot_devices(platform),
    derived_data_path:,
    output_directory:
  )
end

def device_language(business_unit)
  languages = {
    'RSI' => 'it-CH',
    'RTR' => 'de-CH',
    'RTS' => 'fr-CH',
    'SRF' => 'de-CH'
  }
  languages[business_unit]
end

def upload_screenshots(platform)
  platform ||= 'iOS'

  login_with_app_store_connect_api_key
  deliver(
    platform: appstore_platform(platform),
    app_version: xcode_marketing_version(platform),
    skip_binary_upload: true,
    skip_metadata: true,
    overwrite_screenshots: true,
    ignore_language_directory_validation: true,
    precheck_include_in_app_purchases: false,
    force: true # Don't stop to wait manual preview
  )
end

def can_upload_testflight_build(app_identifier, platform, tag_version)
  app_identifier ||= app_config.try_fetch_value(:app_identifier)
  platform ||= 'iOS'
  tag_version ||= tag_version(platform)
  build_number = build_number_from_tag_version(tag_version)

  login_with_app_store_connect_api_key
  appstore_build_number = latest_testflight_build_number(
    platform: appstore_platform(platform),
    app_identifier:
  )

  (appstore_build_number < build_number.to_i)
end

def prepare_appstore_release(platform, business_unit, options)
  platform ||= 'iOS'
  tag_version = tag_version_from_options(options) || tag_version(platform)
  submit_for_review = options[:submit_for_review] || false

  tag = srg_tag_from_tag_version(platform, tag_version)
  if submit_for_review && !git_tag_exists(tag:, remote: true)
    UI.user_error! "Tag version #{tag_version} for #{platform} does not exist. Please set one which is related to existing AppStore build."
  end

  return unless can_run_deliver(business_unit, platform)

  metadata_path = appstore_release_metadata_path(platform, business_unit, tag_version)
  srg_deliver(platform, tag_version, metadata_path, submit_for_review)
end

def srg_deliver(platform, tag_version, metadata_path, submit_for_review)
  login_with_app_store_connect_api_key
  deliver(
    platform: appstore_platform(platform),
    app_version: marketing_version_from_tag_version(tag_version),
    build_number: build_number_from_tag_version(tag_version),
    skip_binary_upload: true,
    skip_screenshots: true,
    metadata_path:,
    precheck_include_in_app_purchases: false,
    submit_for_review:,
    submission_information: { add_id_info_uses_idfa: false },
    automatic_release: true,
    force: true # Don't stop to wait manual preview
  )
end

def appstore_release_metadata_path(platform, business_unit, tag_version)
  platform ||= 'iOS'
  tag_version ||= tag_version(platform)

  # Erase previous metadata
  output_directory = "fastlane/export/#{lane_context[SharedValues::LANE_NAME]}"
  metadata_directory = "#{output_directory}/metadata"
  Dir.chdir('..') { FileUtils.remove_entry(metadata_directory, true) }

  language_directory = "#{metadata_directory}/#{appstore_language(business_unit)}"
  Dir.chdir('..') { FileUtils.mkdir_p(language_directory) }

  collect_appstore_copyright(business_unit, language_directory)
  collect_appstore_release_notes(platform, business_unit, language_directory, tag_version)

  metadata_directory
end

def appstore_language(business_unit)
  languages = {
    'RSI' => 'it',
    'RTR' => 'de-DE',
    'RTS' => 'fr-FR',
    'SRF' => 'de-DE'
  }
  languages[business_unit]
end

def appstore_copyright(business_unit)
  copyrights = {
    'RSI' => 'Radiotelevisione Svizzera',
    'RTR' => 'RTR Radiotelevisiun Svizra Rumantscha',
    'RTS' => 'RTS Radio Télévision Suisse',
    'SRF' => 'Schweizer Radio und Fernsehen (SRF)'
  }
  copyrights[business_unit]
end

def collect_appstore_copyright(business_unit, language_directory)
  copyright = "#{Date.today.year} #{appstore_copyright(business_unit)}"
  file_name = 'copyright.txt'
  Dir.chdir("../#{language_directory}") { File.write(file_name, copyright) }
  UI.important "Copyright for Play #{business_unit}:\n#{copyright}"
end

def collect_appstore_release_notes(platform, business_unit, language_directory, tag_version)
  marketing_version = marketing_version_from_tag_version(tag_version)
  release_notes = get_appstore_release_notes(platform, business_unit, marketing_version)
  file_name = 'release_notes.txt'
  Dir.chdir("../#{language_directory}") { File.write(file_name, release_notes) }
  UI.important "Release notes for Play #{business_unit} #{platform} #{marketing_version}:\n#{release_notes}"
end

def release_notes_minimum_version(platform)
  platform == 'iOS' ? '3.0.0' : '1.0.0'
end

def release_notes_table_for_html(platform, business_unit)
  minimum_version = Gem::Version.new(release_notes_minimum_version(platform))

  file_name = get_appstore_release_notes_file_name(platform)

  table = get_appstore_release_notes_table(file_name, business_unit)
  table = table.sort_by { |row| Gem::Version.new(row[0]) }.reverse
  table.select { |row| Gem::Version.new(row[0]) >= minimum_version }
end

def get_appstore_release_notes(platform, business_unit, marketing_version)
  file_name = get_appstore_release_notes_file_name(platform)
  table = get_appstore_release_notes_table(file_name, business_unit)

  version_row = table.select { |row| row[0] == marketing_version }.first
  release_notes = version_row[1] if version_row

  UI.user_error! "On Crowdin, #{file_name} for #{business_unit} has no release notes for #{marketing_version} version." unless release_notes

  release_notes
end

def get_appstore_release_notes_table(file_name, business_unit)
  file_path = "/tmp/playsrg-crowdin/#{crowdin_language(business_unit)}/Apple/Play App/#{file_name}"
  CSV.read(file_path)
end

def get_appstore_release_notes_file_name(platform)
  "What_s new #{platform}.csv"
end

def crowdin_language(business_unit)
  languages = {
    'RSI' => 'it-CH',
    'RTR' => 'rm-CH',
    'RTS' => 'fr-CH',
    'SRF' => 'de-CH'
  }
  languages[business_unit]
end

def pull_translations_lane_condition(lane)
  included_lanes = ['prepareappstorerelease', 'releasenotes']
  included_lanes.one? { |i| lane.to_s.downcase.include? i }
end

def skip_pull_translations
  ENV['CROWDIN_TRANSLATIONS_PULLLED'] == '1'
end

def pull_translations
  Dir.chdir('..') { sh 'Scripts/crowdin.sh pull --skip-copies' }
  ENV['CROWDIN_TRANSLATIONS_PULLLED'] = '1'
end

def beta_workflow(platform)
  commits = what_s_new_beta_commits(platform)

  tag_beta(platform)
  bump_build_number_beta
  commits.append(last_git_commit[:commit_hash])

  cherrypick_beta_workflow_on_main(commits)
end

# Beta workflow: tag the new beta and push to the repository only if we are on the main branch.
def tag_beta(platform)
  return unless git_branch_name == github_main_branch

  tag = srg_tag(platform)

  git_pull(only_tags: true)
  if git_tag_exists(tag:)
    UI.important "Tag \"#{tag}\" already exists. Probably done by an other build (to AppCenter, to TestFlight or did it manually). ⚠️"
  else
    add_git_tag(tag:, sign: true)
    UI.message "Tag \"#{tag}\" created. ✅"
    push_git_tags
    ENV['OVERRIDE_PLAY_TAG'] = tag
  end
end

# Beta workflow: bump build number and push to the repository on any branches.
def bump_build_number_beta
  bump_build_number_commit
  git_pull(rebase: true)
  push_to_git_remote(tags: false)
end

# Cherrypick on main branch if we are on an other branch.
def cherrypick_beta_workflow_on_main(commits)
  branch_name = git_branch_name
  main_branch = github_main_branch
  return if branch_name == main_branch

  jira_issue = sh('git rev-parse --abbrev-ref HEAD 2> /dev/null | grep -oE "[A-Z]+-[0-9]+"').strip

  Dir.chdir('..') do
    sh "git checkout #{main_branch}"
    sh "git pull --rebase origin #{main_branch}"
    commits.each do |commit|
      message = cherry_pick_commit_message(commit, jira_issue)

      sh "git cherry-pick --no-commit #{commit}"
      sh "git commit -m \"#{message}\"" unless git_status_clean
    end
    sh "git push origin #{main_branch}:#{main_branch}"
    sh "git checkout #{branch_name}"
  end
end

def cherry_pick_commit_message(commit, jira_issue)
  original_message = sh("git log -1 --pretty=%B #{commit}").strip
  original_message.gsub(jira_issue, '').strip
end

def git_branch_name
  branch_name = sh "git branch | grep \\* | cut -d ' ' -f2"

  if branch_name.include? '(HEAD'
    sh 'git fetch --all'
    sh_branch = 'git branch --all --contains HEAD'
    remove = 'remotes/origin/'
    branch_name = sh "#{sh_branch} | grep -o '#{remove}[^ ]*' | sed 's|#{remove}||'"
  end

  branch_name.strip
end

def git_status_clean
  sh('git status --porcelain').strip.empty?
end

def beta_app_review_info
  {
    contact_email: ENV.fetch('ITUNES_CONNECT_REVIEW_EMAIL', nil),
    contact_first_name: ENV.fetch('ITUNES_CONNECT_REVIEW_FIRST_NAME', nil),
    contact_last_name: ENV.fetch('ITUNES_CONNECT_REVIEW_LAST_NAME', nil),
    contact_phone: ENV.fetch('ITUNES_CONNECT_REVIEW_PHONE', nil)
  }
end

# Bump marketing version if one AppStore version is same as the current version.
def bump_marketing_version_flow(platform, appstore_versions)
  UI.message "Checking Play #{platform} marketing version... #{appstore_versions}"
  appstore_version = appstore_versions.map { |version| Gem::Version.new(version) }.max
  current_version = Gem::Version.new(xcode_marketing_version(platform))
  UI.message "AppStore version: #{appstore_version}, current version: #{current_version}"

  if appstore_version == current_version
    bump_marketing_version_commit(platform)
    git_pull(rebase: true)
    push_to_git_remote(tags: false)
    UI.success "Play #{platform} marketing version bumped to #{xcode_marketing_version(platform)}. ✅"
    true
  else
    UI.message "Play #{platform} marketing version is currently #{xcode_marketing_version(platform)}."
    false
  end
end

def git_last_commit_hashes(count)
  sh("git log --pretty=format:'%H' -n #{count}").split("\n")
end

def git_commited_files(commit_hash)
  sh("git show --pretty=format:'' --name-only #{commit_hash}").split("\n")
end

def bump_marketing_version_commit(platform)
  marketing_version = bump_marketing_version(xcode_marketing_version(platform))
  marketing_version = xcode_override_marketing_version(platform, marketing_version)
  commit_version_bump(
    xcodeproj: 'PlaySRG.xcodeproj',
    message: "Bump #{platform} version to #{marketing_version}",
    include: srg_xcconfig_path(platform),
    ignore: /.+/
  )
end

def bump_build_number_commit
  build_number = bump_build_number(xcode_build_number)
  build_number = xcode_override_build_number(build_number)
  commit_version_bump(
    xcodeproj: 'PlaySRG.xcodeproj',
    message: "Bump build number to #{build_number}",
    include: srg_xcconfig_common_path,
    ignore: /.+/
  )
end

def bump_build_number(build_number)
  build_number.to_i + 1
end

def bump_marketing_version(marketing_version)
  major, minor, patch = marketing_version.split('.').map(&:to_i)
  patch += 1
  [major, minor, patch].join('.')
end

def snapshot_devices(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    snapshot_ios_devices
  else
    snapshot_tvos_devices
  end
end

def snapshot_ios_devices
  [
    'iPhone 16 Pro', # 6.9 inch
    'iPad Pro 13-inch (M4)' # 13 inch
  ]
end

def snapshot_tvos_devices
  [
    'Apple TV'
  ]
end

def spaceship_login
  ENV['FASTLANE_ITC_TEAM_ID'] = app_config.try_fetch_value(:itc_team_id)
  Spaceship::Tunes.login
  Spaceship::Tunes.select_team
end

def spaceship_login_with_api_key(business_unit = nil)
  asc_api_key = srg_app_store_connect_api_key(business_unit)
  return unless asc_api_key

  token = Spaceship::ConnectAPI::Token.create(
    key_id: asc_api_key[:id],
    issuer_id: asc_api_key[:issuerId],
    filepath: asc_api_key[:filePath]
  )

  Spaceship::ConnectAPI.token = token
end

def spaceship_platform(platform)
  spaceship_platforms = { 'iOS' => 'IOS', 'tvOS' => 'TV_OS' }
  spaceship_platforms[platform]
end

def spaceship_email_required(email)
  return if !email || (email.strip !~ URI::MailTo::EMAIL_REGEXP)

  email.strip
end

def spaceship_bu_appstore_build_app(business_unit)
  app_identifier = appstore_build_identifiers[business_unit_index(business_unit)]
  spaceship_app(app_identifier)
end

def spaceship_app(app_identifier)
  app = Spaceship::ConnectAPI::App.find(app_identifier)
  UI.important "#{app_identifier} app does not exist. ⚠️" unless app
  app
end

def spaceship_get_group(app, group_name)
  group = app.get_beta_groups(filter: { name: group_name }).first
  UI.important "#{group_name} group does not exist for #{app.name}. ⚠️" unless group
  group
end

def spaceship_get_tester(app, email)
  Spaceship::TestFlight::Tester.search(app_id: app.id, text: email).first
end

def spaceship_delete_tester(app, tester)
  Spaceship::ConnectAPI.delete_beta_tester_from_apps(
    beta_tester_id: tester.tester_id,
    app_ids: [app.id]
  )
end

def spaceship_new_tester(email, first_name, last_name)
  { email:, firstName: first_name, lastName: last_name }
end

def spaceship_add_tester(group, email, first_name, last_name)
  tester = spaceship_new_tester(email, first_name, last_name)
  group.post_bulk_beta_tester_assignments(beta_testers: [tester])
end

def spaceship_app_live_version(platform, app)
  app.get_live_app_store_version(platform: spaceship_platform(platform))
end

def spaceship_app_latest_known_version(platform, app)
  includes = Spaceship::ConnectAPI::AppStoreVersion::ESSENTIAL_INCLUDES
  app.get_latest_app_store_version(platform: spaceship_platform(platform), includes:)
end

def spaceship_app_version_localization(version)
  Spaceship::ConnectAPI::AppStoreVersionLocalization.all(app_store_version_id: version.id).first
end

def can_run_deliver(business_unit, platform)
  spaceship_login_with_api_key(business_unit)
  app = spaceship_bu_appstore_build_app(business_unit)
  return false unless app

  latest_version = spaceship_app_latest_known_version(platform, app)
  return true unless latest_version

  build_version = latest_version.build ? latest_version.build.version : 'NaN'
  app_store_state = latest_version.app_store_state
  UI.important "Play #{business_unit} #{platform} latest version #{latest_version.version_string} (#{build_version}) is #{app_store_state}."

  review_states = [APP_STORE_STATE::WAITING_FOR_REVIEW, APP_STORE_STATE::IN_REVIEW]
  return true unless review_states.include? app_store_state

  UI.success "Play #{business_unit} #{platform} latest version #{latest_version.version_string} (#{build_version}) is already submitted. ✅"
  false
end

def spaceship_app_beta_group_builds(app)
  group_builds = []
  app.get_beta_groups.each do |group|
    state = group.is_internal_group ? 'Internal' : 'External'
    UI.message "TestFlight group: #{group.name} (#{state}). Getting builds..."

    builds = group.fetch_builds.filter { |build| !build.expired }
    group_builds.push({ group:, builds: })
  end
  group_builds
end

def spaceship_app_builds(app_id, version, platform)
  Spaceship::ConnectAPI::Build.all(
    app_id:,
    version:,
    platform: spaceship_platform(platform)
  )
end

def spaceship_app_internal_groups_state(beta_detail, group_builds, build_id)
  build_filter = ->(group_build) { group_build[:builds].map(&:id).include?(build_id) }
  filter_group_builds = group_builds.filter(&build_filter)
  beta_groups = filter_group_builds.map { |group_build| group_build[:group] }

  internal_groups = beta_groups.filter(&:is_internal_group)
  group_names = internal_groups.map(&:name).join(', ')
  state = beta_detail.internal_build_state
  message = "- Internal: #{group_names} (#{state})"
  { state:, message: }
end

def spaceship_app_external_groups_state(beta_detail, group_builds, build_id)
  build_filter = ->(group_build) { group_build[:builds].map(&:id).include?(build_id) }
  filter_group_builds = group_builds.filter(&build_filter)
  beta_groups = filter_group_builds.map { |group_build| group_build[:group] }

  external_groups = beta_groups.reject(&:is_internal_group)
  group_names = external_groups.map(&:name).join(', ')
  state = beta_detail.external_build_state
  message = "- External: #{group_names} (#{state})"
  { state:, message: }
end

def run_publish_release_notes(need_update)
  UI.message 'Release notes: no new AppStore releases have been found.'
  return unless need_update

  UI.command_output 'Release notes: new AppStore releases have been found. Update github page.'
  sh 'bundle exec fastlane ios publishReleaseNotes'
end

def copy_static_github_pages_files(output_directory)
  source_directory = 'fastlane/gh-pages'
  copy_static_github_pages_files_from_to(source_directory, output_directory)

  source_deployments_directory = "#{source_directory}/deployments"
  output_deployments_directory = "#{output_directory}/deployments"
  copy_static_github_pages_files_from_to(source_deployments_directory, output_deployments_directory)
end

def copy_static_github_pages_files_from_to(source_directory, output_directory)
  Dir.chdir('..') do
    FileUtils.mkdir_p(output_directory)
    Dir.glob("#{source_directory}/*.{png,html}").each do |file|
      FileUtils.cp(file, output_directory)
    end
  end
end

def publish_on_github_pages(output_directory, releases_directory)
  branch_name = git_branch_name

  Dir.chdir('..') do
    sh 'git branch -Dq gh-pages &>/dev/null || true'
    sh 'git checkout --orphan gh-pages'
    sh 'git reset --hard'
    sh "mv \"#{output_directory}/index.html\" ./"
    sh "mv \"#{output_directory}/preview.png\" ./"
    sh "mv \"#{output_directory}/deployments\" ./"
    sh "mv \"#{releases_directory}\" ./"
    sh 'git add index.html preview.png releases/* deployments/*'
    sh 'git commit -m "Publish release notes"'
    sh 'git push origin gh-pages --force'
    sh "git checkout #{branch_name}"
    sh 'git branch -D gh-pages'
  end
end

def slack_beta_release(platform, tag_version)
  tag_version ||= tag_version(platform)
  return unless ENV['SLACK_URL'] && ENV['SLACK_CHANNEL']

  slack(
    message: "#{platform_emoji(platform)} Welcome to the latest Play #{platform} beta 🎯",
    channel: ENV.fetch('SLACK_CHANNEL', nil),
    default_payloads: [],
    payload: slack_payload(platform, tag_version),
    attachment_properties: {
      'footer' => 'TestFlight review for external distribution could take up to 24 hours.'
    }
  )
end

def platform_emoji(platform)
  platform ||= 'iOS'

  if platform == 'iOS'
    '📱'
  else
    '📺'
  end
end

def slack_payload(platform, tag_version)
  build_number = build_number_from_tag_version(tag_version)
  marketing_version = marketing_version_from_tag_version(tag_version)

  {
    'Version' => "`Play #{platform} #{marketing_version} (#{build_number})`",
    'Release notes' => what_s_new_for_beta(platform, tag_version),
    'Jira issues' => jira_issues_url(platform, marketing_version),
    'Distribution date' => Time.new.strftime('%d.%m.%Y %H:%M %z')
  }
end

def jira_issues_url(platform, marketing_version)
  return 'NaN' unless ENV['JIRA_URL']

  jira_issues_query = "fixVersion%20%3D%20%22Play%20#{platform}%20#{marketing_version}%22"
  "#{ENV.fetch('JIRA_URL', nil)}/issues/?jql=#{jira_issues_query}"
end

# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md

# fastlane reports which actions are used
# No personal data is recorded. Learn more at https://github.com/fastlane/enhancer
